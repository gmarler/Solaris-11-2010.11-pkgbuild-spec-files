--- wine-1.1.22.orig/dlls/ntdll/virtual.c	Sun May 31 17:44:48 2009
+++ wine-1.1.22/dlls/ntdll/virtual.c	Mon Jun  1 21:44:53 2009
@@ -148,7 +148,12 @@
 static int use_locks;
 static int force_exec_prot;  /* whether to force PROT_EXEC on all PROT_READ mmaps */
 
+void *virtual_mmap_wrapper( void *addr, size_t size, int prot, int flags, int fd, off64_t offset );
+int virtual_munmap_wrapper( void *addr, size_t size );
+static void *(*orig_mmap)( void *addr, size_t size, int prot, int flags, int fd, off64_t offset );
+static int (*orig_munmap)( void *addr, size_t size );
 
+
 /***********************************************************************
  *           VIRTUAL_GetProtStr
  */
@@ -359,7 +364,7 @@
     {
         /* unmap the part of the area that is below the limit */
         assert( (char *)addr + size > (char *)user_space_limit );
-        munmap( addr, (char *)user_space_limit - (char *)addr );
+        orig_munmap( addr, (char *)user_space_limit - (char *)addr );
         size -= (char *)user_space_limit - (char *)addr;
         addr = user_space_limit;
     }
@@ -386,14 +391,17 @@
  * Unmap an area, or simply replace it by an empty mapping if it is
  * in a reserved area. The csVirtual section must be held by caller.
  */
-static inline void unmap_area( void *addr, size_t size )
+static inline int unmap_area( void *addr, size_t size )
 {
+    int ret = 0;
+
     if (wine_mmap_is_in_reserved_area( addr, size ))
         wine_anon_mmap( addr, size, PROT_NONE, MAP_NORESERVE | MAP_FIXED );
     else if (is_beyond_limit( addr, size, user_space_limit ))
         add_reserved_area( addr, size );
     else
-        munmap( addr, size );
+        ret = orig_munmap( addr, size );
+    return ret;
 }
 
 
@@ -663,12 +671,12 @@
     if ((ULONG_PTR)ptr & mask)
     {
         size_t extra = mask + 1 - ((ULONG_PTR)ptr & mask);
-        munmap( ptr, extra );
+        orig_munmap( ptr, extra );
         ptr = (char *)ptr + extra;
         total_size -= extra;
     }
     if (total_size > wanted_size)
-        munmap( (char *)ptr + wanted_size, total_size - wanted_size );
+        orig_munmap( (char *)ptr + wanted_size, total_size - wanted_size );
     return ptr;
 }
 
@@ -755,7 +763,7 @@
             {
                 /* We couldn't get the address we wanted */
                 if (is_beyond_limit( ptr, size, user_space_limit )) add_reserved_area( ptr, size );
-                else munmap( ptr, size );
+                else orig_munmap( ptr, size );
                 return STATUS_CONFLICTING_ADDRESSES;
             }
             break;
@@ -810,6 +818,140 @@
 
 
 /***********************************************************************
+ *           virtual_mmap_wrapper
+ */
+void *virtual_mmap_wrapper( void *addr, size_t size, int prot, int flags, int fd, off64_t offset )
+{
+    void *ptr;
+    struct alloc_area alloc;
+    sigset_t sigset;
+
+    if (!virtual_heap || (flags & MAP_FIXED))
+        return orig_mmap( addr, size, prot, flags, fd, offset );
+
+    size = ROUND_SIZE( addr, size );
+
+    server_enter_uninterrupted_section( &csVirtual, &sigset );
+
+    if (addr)
+    {
+        addr = ROUND_ADDR( addr, page_mask );
+        switch (wine_mmap_is_in_reserved_area( addr, size ))
+        {
+        case -1: /* partially in a reserved area */
+            break;
+        case 0:  /* not in a reserved area, do a normal allocation */
+            ptr = orig_mmap( addr, size, prot, flags, fd, offset );
+            if (ptr == (void *)-1 && errno == ENOMEM) break;
+            goto done;
+        default:
+        case 1:  /* in a reserved area, make sure the address is available */
+            if (!find_view_range( addr, size ))
+            {
+                /* replace the reserved area by our mapping */
+                ptr = orig_mmap( addr, size, prot, flags | MAP_FIXED, fd, offset );
+                goto done;
+            }
+            break;
+        }
+    }
+
+    alloc.size = size;
+    alloc.mask = page_mask;
+    alloc.top_down = 1;
+    alloc.limit = address_space_limit;
+    if (wine_mmap_enum_reserved_areas( alloc_reserved_area_callback, &alloc, 1 ))
+        ptr = orig_mmap( alloc.result, size, prot, flags | MAP_FIXED, fd, offset );
+    else
+        ptr = orig_mmap( NULL, size, prot, flags, fd, offset );
+
+done:
+    if (ptr != (void *)-1)
+    {
+        struct file_view *view;
+        WORD vprot = VPROT_COMMITTED | VPROT_SYSTEM | VPROT_NOEXEC;
+
+        if (prot != PROT_NONE)
+        {
+            if (prot & PROT_READ) vprot |= VPROT_READ;
+            if (prot & PROT_WRITE) vprot |= VPROT_WRITE;
+            if (prot & PROT_EXEC) vprot |= VPROT_EXEC;
+        }
+        if (create_view( &view, ptr, size, vprot ))
+        {
+            unmap_area( ptr, size );
+            ptr = (void *)-1;
+            errno = ENOMEM;
+        }
+        TRACE( "%p %lx %x %x %d returning %p-%p\n",
+              addr, (ULONG_PTR)size, prot, flags, fd, ptr, (char *)ptr + size );
+    }
+    server_leave_uninterrupted_section( &csVirtual, &sigset );
+    return ptr;
+}
+
+
+/***********************************************************************
+ *           virtual_munmap_wrapper
+ */
+int virtual_munmap_wrapper( void *addr, size_t size )
+{
+    struct file_view *view, *next, *new_view;
+    sigset_t sigset;
+    char *end;
+    int ret;
+
+    size = ROUND_SIZE( addr, size );
+    addr = ROUND_ADDR( addr, page_mask );
+    end = (char *)addr + size;
+
+    TRACE( "%p-%p\n", addr, end );
+    server_enter_uninterrupted_section( &csVirtual, &sigset );
+
+    LIST_FOR_EACH_ENTRY_SAFE( view, next, &views_list, struct file_view, entry )
+    {
+        if ((char *)view->base >= end) break;
+        if ((char *)view->base + view->size <= (char *)addr) continue;
+
+        if (!(view->protect & VPROT_SYSTEM))
+            FIXME( "unmapping range %p-%p but view %p-%p is not system\n",
+                  addr, (char *)addr + size, view->base, (char *)view->base + size );
+
+        if ((char *)view->base >= (char *)addr)
+        {
+            if ((char *)view->base + view->size <= end)
+            {
+                /* view is entirely within the unmapped space, remove it */
+                TRACE( "deleting view %p-%p\n", view->base, (char *)view->base + view->size );
+                delete_view( view );
+                continue;
+            }
+            /* move the base to contain the remaining part of the view */
+            TRACE( "rebasing view %p-%p to %p\n", view->base, (char *)view->base + view->size, end );
+            view->base = end;
+            break;
+        }
+        if ((char *)view->base + view->size <= end)
+        {
+            /* truncate the view */
+            TRACE( "truncating view %p-%p to %p\n", view->base, (char *)view->base + view->size, addr );
+            view->size = (char *)addr - (char *)view->base;
+            continue;
+        }
+        /* create a new view for the remaining area */
+        TRACE( "creating new view %p-%p\n", end, (char *)view->base + view->size );
+        create_view( &new_view, end, (char *)view->base + view->size - end, view->protect );
+        view->size = (char *)addr - (char *)view->base;
+        break;
+    }
+
+    ret = unmap_area( addr, size );
+    server_leave_uninterrupted_section( &csVirtual, &sigset );
+    return ret;
+}
+
+
+/***********************************************************************
  *           map_file_into_view
  *
  * Wrapper for mmap() to map a file into a view, falling back to read if mmap fails.
@@ -830,7 +972,7 @@
     {
         int flags = MAP_FIXED | (shared_write ? MAP_SHARED : MAP_PRIVATE);
 
-        if (mmap( (char *)view->base + start, size, prot, flags, fd, offset ) != (void *)-1)
+        if (orig_mmap( (char *)view->base + start, size, prot, flags, fd, offset ) != (void *)-1)
             goto done;
 
         /* mmap() failed; if this is because the file offset is not    */
@@ -944,7 +1086,7 @@
         addr = wine_anon_mmap( low_64k, dosmem_size - 0x10000, unix_prot, 0 );
         if (addr != low_64k)
         {
-            if (addr != (void *)-1) munmap( addr, dosmem_size - 0x10000 );
+            if (addr != (void *)-1) orig_munmap( addr, dosmem_size - 0x10000 );
             return map_view( view, NULL, dosmem_size, 0xffff, 0, vprot );
         }
     }
@@ -961,7 +1103,7 @@
         }
         else
         {
-            if (addr != (void *)-1) munmap( addr, 0x10000 - page_size );
+            if (addr != (void *)-1) orig_munmap( addr, 0x10000 - page_size );
             addr = low_64k;
             TRACE( "failed to map low 64K range\n" );
         }
@@ -1309,6 +1451,11 @@
         }
     }
 
+    assert(wine_mmap != NULL);
+    assert(wine_munmap != NULL);
+    orig_mmap = wine_mmap;
+    orig_munmap = wine_munmap;
+
     /* try to find space in a reserved area for the virtual heap */
     if (!wine_mmap_enum_reserved_areas( alloc_virtual_heap, &heap_base, 1 ))
         heap_base = wine_anon_mmap( NULL, VIRTUAL_HEAP_SIZE, PROT_READ|PROT_WRITE, 0 );
@@ -1328,6 +1475,16 @@
     use_locks = 1;
 }
 
+
+/***********************************************************************
+ *           virtual_init_mmap
+ */
+void virtual_init_mmap(void)
+{
+    wine_mmap = virtual_mmap_wrapper;
+    wine_munmap = virtual_munmap_wrapper;
+}
+
 
 /***********************************************************************
  *           virtual_get_system_info
--- wine-1.1.22.orig/dlls/ntdll/ntdll_misc.h	Sun May 31 17:44:48 2009
+++ wine-1.1.22/dlls/ntdll/ntdll_misc.h	Mon Jun  1 21:07:21 2009
@@ -67,6 +67,7 @@
 extern void actctx_init(void);
 extern void virtual_init(void);
 extern void virtual_init_threading(void);
+extern void virtual_init_mmap(void);
 
 /* server support */
 extern timeout_t server_start_time;
--- wine-1.1.22.orig/dlls/ntdll/thread.c	Sun May 31 17:44:48 2009
+++ wine-1.1.22/dlls/ntdll/thread.c	Mon Jun  1 21:45:50 2009
@@ -330,6 +330,7 @@
     user_shared_data->TickCountLowDeprecated = user_shared_data->u.TickCount.LowPart;
     user_shared_data->TickCountMultiplier = 1 << 24;
 
+    virtual_init_mmap();
     return exe_file;
 }
 
--- wine-1.1.22.orig/loader/main.c	Sun May 31 17:44:48 2009
+++ wine-1.1.22/loader/main.c	Mon Jun  1 22:15:09 2009
@@ -186,7 +186,65 @@
 #endif
 
 
+/***********************************************************************
+ * overrides for mmap, mmap64, munmap
+ */
+#ifdef _LP64
+#define mmap64_override mmap
+#define munmap_override munmap
+#else  /* _LP64 */
+#define mmap_override mmap
+#define mmap64_override mmap64
+#define munmap_override munmap
+
+#ifndef __PRAGMA_REDEFINE_EXTNAME
+/* FIXME: all instances of symbol "mmap" may have been redefined */
+#ifdef __sun
+caddr_t mmap_override( caddr_t addr, size_t size, int prot, int flags, int fd, unsigned long offset )
+#else
+void *mmap_override( void *addr, size_t size, int prot, int flags, int fd, unsigned long offset )
+#endif
+{
+    return wine_mmap( addr, size, prot, flags, fd, offset );
+}
+#endif  /* __PRAGMA_REDEFINE_EXTNAME */
+
+#endif  /* _LP64 */
+
+#ifdef __sun
+caddr_t mmap64_override( caddr_t addr, size_t size, int prot, int flags, int fd, off64_t offset )
+#else
+void *mmap64_override( void *addr, size_t size, int prot, int flags, int fd, off64_t offset )
+#endif
+{
+    return wine_mmap( addr, size, prot, flags, fd, offset );
+}
+
+#ifdef __sun
+int munmap_override( caddr_t addr, size_t size )
+#else
+int munmap_override( void *addr, size_t size )
+#endif
+{
+    return wine_munmap( addr, size );
+}
+
+
 /**********************************************************************
+ *           init_mmap_functions
+ */
+static void init_mmap_functions(void)
+{
+#ifdef _LP64
+    wine_mmap = wine_dlsym( RTLD_NEXT, "mmap", NULL, 0 );
+#else
+    wine_mmap = wine_dlsym( RTLD_NEXT, "mmap64", NULL, 0 );
+#endif
+    wine_munmap = wine_dlsym( RTLD_NEXT, "munmap", NULL, 0 );
+}
+
+
+/**********************************************************************
  *           main
  */
 int main( int argc, char *argv[] )
@@ -209,6 +267,8 @@
         }
     }
 
+    init_mmap_functions();
+
     if (wine_main_preload_info)
     {
         for (i = 0; wine_main_preload_info[i].size; i++)
--- wine-1.1.22.orig/loader/pthread.c	Sun May 31 17:44:48 2009
+++ wine-1.1.22/loader/pthread.c	Mon Jun  1 20:24:09 2009
@@ -205,7 +205,7 @@
 {
     if (interlocked_xchg_add( &nb_threads, -1 ) <= 1) exit( info->exit_status );
     wine_ldt_free_fs( info->teb_sel );
-    if (info->teb_size) munmap( info->teb_base, info->teb_size );
+    if (info->teb_size) wine_munmap( info->teb_base, info->teb_size );
     pthread_exit( (void *)info->exit_status );
 }
 
--- wine-1.1.22.orig/libs/wine/mmap.c	Sun May 31 17:44:48 2009
+++ wine-1.1.22/libs/wine/mmap.c	Mon Jun  1 20:36:01 2009
@@ -43,6 +43,9 @@
 
 #ifdef HAVE_MMAP
 
+void *(*wine_mmap)( void *addr, size_t size, int prot, int flags, int fd, off64_t offset );
+int (*wine_munmap)( void *addr, size_t size );
+
 struct reserved_area
 {
     struct list entry;
@@ -140,12 +143,12 @@
 
         /* Perform the mapping with MAP_FIXED set.  This is safe
            now, as none of the pages is currently in use. */
-        result = mmap( addr, len, prot, flags | MAP_FIXED, fildes, off );
+        result = wine_mmap( addr, len, prot, flags | MAP_FIXED, fildes, off );
         if ( result == addr )
             _exit(0);
 
         if ( result != (void *) -1 ) /* This should never happen ... */
-            munmap( result, len );
+            wine_munmap( result, len );
 
        _exit(1);
     }
@@ -174,7 +177,8 @@
 
     if (!vm_allocate(mach_task_self(),&result,len,0))
     {
-        if (mmap( (void *)result, len, prot, flags | MAP_FIXED, fildes, off ) != MAP_FAILED)
+        if (wine_mmap( (void *)result, len, prot, flags | MAP_FIXED,
+                                    fildes, off ) != MAP_FAILED)
             return 1;
         vm_deallocate(mach_task_self(),result,len);
     }
@@ -213,7 +217,7 @@
             return start;
 #endif
     }
-    return mmap( start, size, prot, flags, get_fdzero(), 0 );
+    return wine_mmap( start, size, prot, flags, get_fdzero(), 0 );
 }
 
 
@@ -232,8 +236,8 @@
 #elif defined(__APPLE__)
     return try_mmap_fixed( addr, size, PROT_NONE, flags, get_fdzero(), 0 );
 #endif
-    ptr = mmap( addr, size, PROT_NONE, flags, get_fdzero(), 0 );
-    if (ptr != addr && ptr != (void *)-1)  munmap( ptr, size );
+    ptr = wine_mmap( addr, size, PROT_NONE, flags, get_fdzero(), 0 );
+    if (ptr != addr && ptr != (void *)-1) wine_munmap( ptr, size );
     return (ptr == addr);
 }
 
@@ -260,8 +264,9 @@
             if (mincore( (caddr_t)addr + i, pagesize, &vec ) != -1) break;
 
         i &= ~granularity_mask;
-        if (i && mmap( addr, i, PROT_NONE, MAP_FIXED | MAP_PRIVATE | MAP_ANON | MAP_NORESERVE,
-                       get_fdzero(), 0 ) != (void *)-1)
+        if (i && wine_mmap( addr, i,
+                                         PROT_NONE, MAP_FIXED | MAP_PRIVATE | MAP_ANON | MAP_NORESERVE,
+                                         get_fdzero(), 0 ) != (void *)-1)
             wine_mmap_add_reserved_area( addr, i );
 
         i += granularity_mask + 1;
@@ -327,7 +332,7 @@
     ptr = wine_anon_mmap( (void *)page_size, dos_area_size - page_size, PROT_NONE, MAP_NORESERVE );
     if (ptr != (void *)page_size)
     {
-        if (ptr != (void *)-1) munmap( ptr, dos_area_size - page_size );
+        if (ptr != (void *)-1) wine_munmap( ptr, dos_area_size - page_size );
         return;
     }
     /* now add first page with MAP_FIXED */
@@ -479,7 +484,7 @@
                 if ((char *)area->base + area->size > (char *)addr + size)
                 {
                     /* range overlaps beginning of area only -> shrink area */
-                    if (unmap) munmap( area->base, (char *)addr + size - (char *)area->base );
+                    if (unmap) wine_munmap( area->base, (char *)addr + size - (char *)area->base );
                     area->size -= (char *)addr + size - (char *)area->base;
                     area->base = (char *)addr + size;
                     break;
@@ -488,7 +493,7 @@
                 {
                     /* range contains the whole area -> remove area completely */
                     ptr = list_next( &reserved_areas, ptr );
-                    if (unmap) munmap( area->base, area->size );
+                    if (unmap) wine_munmap( area->base, area->size );
                     list_remove( &area->entry );
                     free( area );
                     continue;
@@ -508,13 +513,13 @@
                     }
                     else size = (char *)area->base + area->size - (char *)addr;
                     area->size = (char *)addr - (char *)area->base;
-                    if (unmap) munmap( addr, size );
+                    if (unmap) wine_munmap( addr, size );
                     break;
                 }
                 else
                 {
                     /* range overlaps end of area only -> shrink area */
-                    if (unmap) munmap( addr, (char *)area->base + area->size - (char *)addr );
+                    if (unmap) wine_munmap( addr, (char *)area->base + area->size - (char *)addr );
                     area->size = (char *)addr - (char *)area->base;
                 }
             }
--- wine-1.1.22.orig/include/wine/library.h	Fri May 22 11:58:14 2009
+++ wine-1.1.22/include/wine/library.h	Mon Jun  1 21:15:14 2009
@@ -75,6 +75,8 @@
 
 /* memory mappings */
 
+extern void *(*wine_mmap)( void *addr, size_t size, int prot, int flags, int fd, off64_t offset );
+extern int (*wine_munmap)( void *addr, size_t size );
 extern void *wine_anon_mmap( void *start, size_t size, int prot, int flags );
 extern void wine_mmap_add_reserved_area( void *addr, size_t size );
 extern void wine_mmap_remove_reserved_area( void *addr, size_t size, int unmap );
