diff -ru deluge-0.5.5.orig/setup.py deluge-0.5.5/setup.py
--- deluge-0.5.5.orig/setup.py	2007年  9月 17日 一 01:06:08
+++ deluge-0.5.5/setup.py	2007年  9月 17日 一 00:49:37
@@ -96,12 +96,12 @@
 #    it has been removed to prevent confusion.
 
 if not OS == "win":
-    EXTRA_COMPILE_ARGS = ["-Wno-missing-braces", 
+    EXTRA_COMPILE_ARGS = [
                 "-DHAVE_INCLUDE_LIBTORRENT_ASIO____ASIO_HPP=1", 
                 "-DHAVE_INCLUDE_LIBTORRENT_ASIO_SSL_STREAM_HPP=1", 
                 "-DHAVE_INCLUDE_LIBTORRENT_ASIO_IP_TCP_HPP=1", 
                 "-DHAVE_PTHREAD=1", "-DTORRENT_USE_OPENSSL=1", "-DHAVE_SSL=1", 
-                "-DNDEBUG=1", "-O2"]
+                "-DNDEBUG=1"]
     if ARCH == "x64":
         EXTRA_COMPILE_ARGS.append("-DAMD64")
 
@@ -175,7 +175,8 @@
                     include_dirs = includedirs,
             libraries = librariestype,
                     extra_compile_args = EXTRA_COMPILE_ARGS,
-                    sources = sources)
+                    sources = sources,
+                    language = 'c++')
 # Thanks to Iain Nicol for code to save the location for installed prefix
 # At runtime, we need to know where we installed the data to.
 
diff -ru deluge-0.5.5.orig/libtorrent/include/libtorrent/buffer.hpp deluge-0.5.5/libtorrent/include/libtorrent/buffer.hpp
--- deluge-0.5.5.orig/libtorrent/include/libtorrent/buffer.hpp	2007年  9月  3日 一 03:14:45
+++ deluge-0.5.5/libtorrent/include/libtorrent/buffer.hpp	2007年  9月 17日 一 00:49:37
@@ -246,7 +246,7 @@
 	 assert(m_write_cursor == m_last);
     m_write_cursor = m_first;
 
-    memcpy(m_write_cursor, first, n);
+    std::memcpy(m_write_cursor, first, n);
     m_write_cursor += n;
 }
 
diff -ru deluge-0.5.5.orig/libtorrent/include/libtorrent/xml_parse.hpp deluge-0.5.5/libtorrent/include/libtorrent/xml_parse.hpp
--- deluge-0.5.5.orig/libtorrent/include/libtorrent/xml_parse.hpp	2007年  9月 17日 一 01:06:03
+++ deluge-0.5.5/libtorrent/include/libtorrent/xml_parse.hpp	2007年  9月 17日 一 00:49:37
@@ -128,7 +128,7 @@
 				*(p-1) = '?';
 				tag_end = p - 1;
 			}
-			else if (start + 5 < p && memcmp(start, "!--", 3) == 0 && memcmp(p-2, "--", 2) == 0)
+			else if (start + 5 < p && std::memcmp(start, "!--", 3) == 0 && std::memcmp(p-2, "--", 2) == 0)
 			{
 				start += 3;
 				*(p-2) = 0;
diff -ru deluge-0.5.5.orig/libtorrent/include/libtorrent/asio/detail/socket_ops.hpp deluge-0.5.5/libtorrent/include/libtorrent/asio/detail/socket_ops.hpp
--- deluge-0.5.5.orig/libtorrent/include/libtorrent/asio/detail/socket_ops.hpp	2007年  9月  3日 一 03:14:45
+++ deluge-0.5.5/libtorrent/include/libtorrent/asio/detail/socket_ops.hpp	2007年  9月 17日 一 00:49:37
@@ -130,7 +130,10 @@
 #if defined(BOOST_WINDOWS) || defined(__CYGWIN__)
   b.buf = static_cast<char*>(data);
   b.len = static_cast<u_long>(size);
-#else // defined(BOOST_WINDOWS) || defined(__CYGWIN__)
+#elif defined(__SUNPRO_CC)
+  b.iov_base = static_cast<char*>(data);
+  b.iov_len = size;
+#else // defined(__SUNPRO_CC)
   b.iov_base = data;
   b.iov_len = size;
 #endif // defined(BOOST_WINDOWS) || defined(__CYGWIN__)
@@ -141,7 +144,10 @@
 #if defined(BOOST_WINDOWS) || defined(__CYGWIN__)
   b.buf = static_cast<char*>(const_cast<void*>(data));
   b.len = static_cast<u_long>(size);
-#else // defined(BOOST_WINDOWS) || defined(__CYGWIN__)
+#elif defined(__SUNPRO_CC)
+  b.iov_base = static_cast<char*>(const_cast<void*>(data));
+  b.iov_len = size;
+#else // defined(__SUNPRO_CC)
   b.iov_base = const_cast<void*>(data);
   b.iov_len = size;
 #endif // defined(BOOST_WINDOWS) || defined(__CYGWIN__)
diff -ru deluge-0.5.5.orig/libtorrent/include/libtorrent/asio/impl/error_code.ipp deluge-0.5.5/libtorrent/include/libtorrent/asio/impl/error_code.ipp
--- deluge-0.5.5.orig/libtorrent/include/libtorrent/asio/impl/error_code.ipp	2007年  9月 17日 一 01:06:36
+++ deluge-0.5.5/libtorrent/include/libtorrent/asio/impl/error_code.ipp	2007年  9月 17日 一 00:49:37
@@ -77,16 +77,16 @@
   if (*this == error::socket_type_not_supported)
     return "Socket type not supported.";
 #if defined(__sun) || defined(__QNX__)
-  return strerror(value_);
+  return std::strerror(value_);
 #elif defined(__MACH__) && defined(__APPLE__) \
 || defined(__NetBSD__) || defined(__FreeBSD__) || defined(__OpenBSD__) \
 || defined(_AIX)
   char buf[256] = "";
-  strerror_r(value_, buf, sizeof(buf));
+  std::strerror_r(value_, buf, sizeof(buf));
   return buf;
 #else
   char buf[256] = "";
-  return strerror_r(value_, buf, sizeof(buf));
+  return std::strerror_r(value_, buf, sizeof(buf));
 #endif
 #endif // defined(BOOST_WINDOWS)
 }
diff -ru deluge-0.5.5.orig/libtorrent/src/file.cpp deluge-0.5.5/libtorrent/src/file.cpp
--- deluge-0.5.5.orig/libtorrent/src/file.cpp	2007年  9月 17日 一 01:06:04
+++ deluge-0.5.5/libtorrent/src/file.cpp	2007年  9月 17日 一 00:49:37
@@ -183,7 +183,7 @@
 			{
 				std::stringstream msg;
 				msg << "open failed: '" << path.native_file_string() << "'. "
-					<< strerror(errno);
+					<< std::strerror(errno);
 				throw file_error(msg.str());
 			}
 			m_open_mode = mode;
@@ -215,7 +215,7 @@
 			if (ret == -1)
 			{
 				std::stringstream msg;
-				msg << "read failed: " << strerror(errno);
+				msg << "read failed: " << std::strerror(errno);
 				throw file_error(msg.str());
 			}
 			return ret;
@@ -239,7 +239,7 @@
 			if (ret == -1)
 			{
 				std::stringstream msg;
-				msg << "write failed: " << strerror(errno);
+				msg << "write failed: " << std::strerror(errno);
 				throw file_error(msg.str());
 			}
 			return ret;
@@ -280,7 +280,7 @@
 			if (ret == -1)
 			{
 				std::stringstream msg;
-				msg << "seek failed: '" << strerror(errno)
+				msg << "seek failed: '" << std::strerror(errno)
 					<< "' fd: " << m_fd
 					<< " offset: " << offset
 					<< " seekdir: " << seekdir;
diff -ru deluge-0.5.5.orig/libtorrent/src/http_stream.cpp deluge-0.5.5/libtorrent/src/http_stream.cpp
--- deluge-0.5.5.orig/libtorrent/src/http_stream.cpp	2007年  9月 17日 一 01:06:07
+++ deluge-0.5.5/libtorrent/src/http_stream.cpp	2007年  9月 17日 一 00:49:37
@@ -130,7 +130,7 @@
 		if (found_end)
 		{
 			m_buffer.push_back(0);
-			char* status = strchr(&m_buffer[0], ' ');
+			char* status = std::strchr(&m_buffer[0], ' ');
 			if (status == 0)
 			{
 				(*h)(asio::error::operation_not_supported);
@@ -139,7 +139,7 @@
 			}
 
 			status++;
-			int code = atoi(status);
+			int code = std::atoi(status);
 			if (code != 200)
 			{
 				(*h)(asio::error::operation_not_supported);
diff -ru deluge-0.5.5.orig/libtorrent/src/lsd.cpp deluge-0.5.5/libtorrent/src/lsd.cpp
--- deluge-0.5.5.orig/libtorrent/src/lsd.cpp	2007年  9月 17日 一 01:06:04
+++ deluge-0.5.5/libtorrent/src/lsd.cpp	2007年  9月 17日 一 00:49:37
@@ -202,13 +202,13 @@
 		if (line == end) break;
 		*line = 0;
 		for (char* i = p; i < line; ++i) *i = std::tolower(*i);
-		if (line - p >= 5 && memcmp(p, "port:", 5) == 0)
+		if (line - p >= 5 && std::memcmp(p, "port:", 5) == 0)
 		{
 			p += 5;
 			while (*p == ' ') ++p;
-			port = atoi(p);
+			port = std::atoi(p);
 		}
-		else if (line - p >= 9 && memcmp(p, "infohash:", 9) == 0)
+		else if (line - p >= 9 && std::memcmp(p, "infohash:", 9) == 0)
 		{
 			p += 9;
 			while (*p == ' ') ++p;
diff -ru deluge-0.5.5.orig/libtorrent/src/piece_picker.cpp deluge-0.5.5/libtorrent/src/piece_picker.cpp
--- deluge-0.5.5.orig/libtorrent/src/piece_picker.cpp	2007年  9月 17日 一 01:06:07
+++ deluge-0.5.5/libtorrent/src/piece_picker.cpp	2007年  9月 17日 一 00:56:37
@@ -508,7 +508,7 @@
 		{
 			// find a random position in the destination vector where we will place
 			// this entry.
-			int dst_index = rand() % m_piece_info[priority].size();
+			int dst_index = std::rand() % m_piece_info[priority].size();
 			
 			// copy the entry at that position to the back
 			m_piece_map[m_piece_info[priority][dst_index]].index
@@ -580,7 +580,7 @@
 		{
 			// find a random position in the destination vector where we will place
 			// this entry.
-			int dst_index = rand() % m_piece_info[new_priority].size();
+			int dst_index = std::rand() % m_piece_info[new_priority].size();
 			
 			// copy the entry at that position to the back
 			m_piece_map[m_piece_info[new_priority][dst_index]].index
@@ -1142,7 +1142,7 @@
 			// we're not using rarest first (only for the first
 			// bucket, since that's where the currently downloading
 			// pieces are)
-			int start_piece = rand() % m_piece_map.size();
+			int start_piece = std::rand() % m_piece_map.size();
 			int piece = start_piece;
 			while (num_blocks > 0)
 			{
diff -ru deluge-0.5.5.orig/libtorrent/src/session.cpp deluge-0.5.5/libtorrent/src/session.cpp
--- deluge-0.5.5.orig/libtorrent/src/session.cpp	2007年  9月 17日 一 01:06:06
+++ deluge-0.5.5/libtorrent/src/session.cpp	2007年  9月 17日 一 00:49:37
@@ -77,7 +77,6 @@
 using boost::shared_ptr;
 using boost::weak_ptr;
 using boost::bind;
-using boost::mutex;
 using libtorrent::aux::session_impl;
 
 namespace libtorrent
diff -ru deluge-0.5.5.orig/libtorrent/src/session_impl.cpp deluge-0.5.5/libtorrent/src/session_impl.cpp
--- deluge-0.5.5.orig/libtorrent/src/session_impl.cpp	2007年  9月  8日 六 14:57:16
+++ deluge-0.5.5/libtorrent/src/session_impl.cpp	2007年  9月 17日 一 00:49:37
@@ -93,7 +93,6 @@
 using boost::shared_ptr;
 using boost::weak_ptr;
 using boost::bind;
-using boost::mutex;
 using libtorrent::aux::session_impl;
 
 namespace libtorrent {
@@ -203,7 +202,7 @@
 
 					// lock the session to add the new torrent
 					session_impl::mutex_t::scoped_lock l(m_ses.m_mutex);
-					mutex::scoped_lock l2(m_mutex);
+					boost::mutex::scoped_lock l2(m_mutex);
 					// clear the resume data now that it has been used
 					// (the fast resume data is now parsed and stored in t)
 					t->resume_data = entry();
@@ -273,7 +272,7 @@
 				// This will happen if the storage fails to initialize
 				// for example if one of the files has an invalid filename.
 				session_impl::mutex_t::scoped_lock l(m_ses.m_mutex);
-				mutex::scoped_lock l2(m_mutex);
+				boost::mutex::scoped_lock l2(m_mutex);
 
 				if (m_ses.m_alerts.should_post(alert::fatal))
 				{
@@ -292,7 +291,7 @@
 #ifndef NDEBUG
 				std::cerr << "error while checking resume data\n";
 #endif
-				mutex::scoped_lock l(m_mutex);
+				boost::mutex::scoped_lock l(m_mutex);
 				assert(!m_torrents.empty());
 				m_torrents.pop_front();
 				assert(false);
@@ -309,7 +308,7 @@
 				boost::tie(finished, progress) = processing->torrent_ptr->check_files();
 
 				{
-					mutex::scoped_lock l(m_mutex);
+					boost::mutex::scoped_lock l(m_mutex);
 
 					INVARIANT_CHECK;
 
@@ -335,7 +334,7 @@
 				{
 					// lock the session to add the new torrent
 					session_impl::mutex_t::scoped_lock l(m_ses.m_mutex);
-					mutex::scoped_lock l2(m_mutex);
+					boost::mutex::scoped_lock l2(m_mutex);
 
 					INVARIANT_CHECK;
 
@@ -390,7 +389,7 @@
 			{
 				// This will happen if the storage fails to initialize
 				session_impl::mutex_t::scoped_lock l(m_ses.m_mutex);
-				mutex::scoped_lock l2(m_mutex);
+				boost::mutex::scoped_lock l2(m_mutex);
 
 				if (m_ses.m_alerts.should_post(alert::fatal))
 				{
@@ -416,7 +415,7 @@
 #ifndef NDEBUG
 				std::cerr << "error while checking files\n";
 #endif
-				mutex::scoped_lock l(m_mutex);
+				boost::mutex::scoped_lock l(m_mutex);
 				assert(!m_processing.empty());
 
 				processing.reset();
@@ -610,7 +609,7 @@
 		m_io_service.stop();
 		l.unlock();
 
-		mutex::scoped_lock l2(m_checker_impl.m_mutex);
+		boost::mutex::scoped_lock l2(m_checker_impl.m_mutex);
 		// abort the checker thread
 		m_checker_impl.m_abort = true;
 	}
@@ -1439,7 +1438,7 @@
 	std::vector<torrent_handle> session_impl::get_torrents()
 	{
 		mutex_t::scoped_lock l(m_mutex);
-		mutex::scoped_lock l2(m_checker_impl.m_mutex);
+		boost::mutex::scoped_lock l2(m_checker_impl.m_mutex);
 		std::vector<torrent_handle> ret;
 		for (std::deque<boost::shared_ptr<aux::piece_checker_data> >::iterator i
 			= m_checker_impl.m_torrents.begin()
@@ -1493,7 +1492,7 @@
 
 		// lock the session and the checker thread (the order is important!)
 		mutex_t::scoped_lock l(m_mutex);
-		mutex::scoped_lock l2(m_checker_impl.m_mutex);
+		boost::mutex::scoped_lock l2(m_checker_impl.m_mutex);
 
 		INVARIANT_CHECK;
 
@@ -1568,7 +1567,7 @@
 		assert(!save_path.empty());
 		{
 			// lock the checker_thread
-			mutex::scoped_lock l(m_checker_impl.m_mutex);
+			boost::mutex::scoped_lock l(m_checker_impl.m_mutex);
 
 			// is the torrent currently being checked?
 			if (m_checker_impl.find_torrent(info_hash))
@@ -1665,7 +1664,7 @@
 
 		if (h.m_chk)
 		{
-			mutex::scoped_lock l(m_checker_impl.m_mutex);
+			boost::mutex::scoped_lock l(m_checker_impl.m_mutex);
 
 			aux::piece_checker_data* d = m_checker_impl.find_torrent(h.m_info_hash);
 			if (d != 0)
@@ -1998,7 +1997,7 @@
 		// destructed and then the invariant will be broken).
 
 		{
-			mutex::scoped_lock l(m_checker_impl.m_mutex);
+			boost::mutex::scoped_lock l(m_checker_impl.m_mutex);
 			// abort the checker thread
 			m_checker_impl.m_abort = true;
 
diff -ru deluge-0.5.5.orig/libtorrent/src/sha1.cpp deluge-0.5.5/libtorrent/src/sha1.cpp
--- deluge-0.5.5.orig/libtorrent/src/sha1.cpp	2007年  9月  3日 一 03:14:45
+++ deluge-0.5.5/libtorrent/src/sha1.cpp	2007年  9月 17日 一 00:49:37
@@ -20,7 +20,6 @@
 // #include <stdint.h>
 
 #include <boost/cstdint.hpp>
-using boost::uint32_t;
 using boost::uint8_t;
 
 #include "libtorrent/config.hpp"
@@ -27,13 +26,13 @@
 
 struct TORRENT_EXPORT SHA_CTX
 {
-	uint32_t state[5];
-	uint32_t count[2];
+	boost::uint32_t state[5];
+	boost::uint32_t count[2];
 	uint8_t buffer[64];
 };
 
 TORRENT_EXPORT void SHA1_Init(SHA_CTX* context);
-TORRENT_EXPORT void SHA1_Update(SHA_CTX* context, uint8_t const* data, uint32_t len);
+TORRENT_EXPORT void SHA1_Update(SHA_CTX* context, uint8_t const* data, boost::uint32_t len);
 TORRENT_EXPORT void SHA1_Final(uint8_t* digest, SHA_CTX* context);
 
 namespace
@@ -41,7 +40,7 @@
 	union CHAR64LONG16
 	{
 		uint8_t c[64];
-		uint32_t l[16];
+		boost::uint32_t l[16];
 	};
 
 #define rol(value, bits) (((value) << (bits)) | ((value) >> (32 - (bits))))
@@ -50,7 +49,7 @@
 // I got the idea of expanding during the round function from SSLeay
 	struct little_endian_blk0
 	{
-		static uint32_t apply(CHAR64LONG16* block, int i)
+		static boost::uint32_t apply(CHAR64LONG16* block, int i)
 		{
 			return block->l[i] = (rol(block->l[i],24)&0xFF00FF00)
 				| (rol(block->l[i],8)&0x00FF00FF);
@@ -59,7 +58,7 @@
 
 	struct big_endian_blk0
 	{
-		static uint32_t apply(CHAR64LONG16* block, int i)
+		static boost::uint32_t apply(CHAR64LONG16* block, int i)
 		{
 			return  block->l[i];
 		}
@@ -78,10 +77,10 @@
 
 	// Hash a single 512-bit block. This is the core of the algorithm.
 	template <class BlkFun>
-	void SHA1Transform(uint32_t state[5], uint8_t const buffer[64])
+	void SHA1Transform(boost::uint32_t state[5], uint8_t const buffer[64])
 	{
 		using namespace std;
-		uint32_t a, b, c, d, e;
+		boost::uint32_t a, b, c, d, e;
 
 		CHAR64LONG16* block;
 		uint8_t workspace[64];
@@ -136,10 +135,10 @@
 	}
 
 	template <class BlkFun>
-	void internal_update(SHA_CTX* context, uint8_t const* data, uint32_t len)
+	void internal_update(SHA_CTX* context, uint8_t const* data, boost::uint32_t len)
 	{
 		using namespace std;
-		uint32_t i, j;	// JHB
+		boost::uint32_t i, j;	// JHB
 
 #ifdef VERBOSE
 		SHAPrintContext(context, "before");
@@ -169,7 +168,7 @@
 
 	bool is_big_endian()
 	{
-		uint32_t test = 1;
+		boost::uint32_t test = 1;
 		return *reinterpret_cast<uint8_t*>(&test) == 0;
 	}
 }
@@ -190,7 +189,7 @@
 
 // Run your data through this.
 
-void SHA1_Update(SHA_CTX* context, uint8_t const* data, uint32_t len)
+void SHA1_Update(SHA_CTX* context, uint8_t const* data, boost::uint32_t len)
 {
 #if defined __BIG_ENDIAN__
 	internal_update<big_endian_blk0>(context, data, len);
@@ -213,7 +212,7 @@
 {
 	uint8_t finalcount[8];
 
-	for (uint32_t i = 0; i < 8; ++i)
+	for (boost::uint32_t i = 0; i < 8; ++i)
 	{
 		// Endian independent
 		finalcount[i] = static_cast<uint8_t>(
@@ -226,7 +225,7 @@
 		SHA1_Update(context, (uint8_t const*)"\0", 1);
 	SHA1_Update(context, finalcount, 8);  // Should cause a SHA1Transform()
 
-	for (uint32_t i = 0; i < 20; ++i)
+	for (boost::uint32_t i = 0; i < 20; ++i)
 	{
 		digest[i] = static_cast<unsigned char>(
 			(context->state[i>>2] >> ((3-(i & 3)) * 8) ) & 255);
diff -ru deluge-0.5.5.orig/libtorrent/src/storage.cpp deluge-0.5.5/libtorrent/src/storage.cpp
--- deluge-0.5.5.orig/libtorrent/src/storage.cpp	2007年  9月 17日 一 01:06:08
+++ deluge-0.5.5/libtorrent/src/storage.cpp	2007年  9月 17日 一 00:49:37
@@ -2027,7 +2027,7 @@
 
 		const int stack_buffer_size = 16*1024;
 		char zeroes[stack_buffer_size];
-		memset(zeroes, 0, stack_buffer_size);
+		std::memset(zeroes, 0, stack_buffer_size);
 		
 		bool written = false;
 
diff -ru deluge-0.5.5.orig/libtorrent/src/torrent.cpp deluge-0.5.5/libtorrent/src/torrent.cpp
--- deluge-0.5.5.orig/libtorrent/src/torrent.cpp	2007年  9月 17日 一 01:06:05
+++ deluge-0.5.5/libtorrent/src/torrent.cpp	2007年  9月 17日 一 00:49:37
@@ -78,7 +78,6 @@
 using boost::tuples::get;
 using boost::tuples::make_tuple;
 using boost::bind;
-using boost::mutex;
 using libtorrent::aux::session_impl;
 
 namespace
diff -ru deluge-0.5.5.orig/libtorrent/src/torrent_handle.cpp deluge-0.5.5/libtorrent/src/torrent_handle.cpp
--- deluge-0.5.5.orig/libtorrent/src/torrent_handle.cpp	2007年  9月  3日 一 03:14:45
+++ deluge-0.5.5/libtorrent/src/torrent_handle.cpp	2007年  9月 17日 一 00:55:30
@@ -75,7 +75,6 @@
 #endif
 
 using boost::bind;
-using boost::mutex;
 using libtorrent::aux::session_impl;
 
 namespace libtorrent
@@ -130,7 +129,7 @@
 		assert(max_uploads >= 2 || max_uploads == -1);
 
 		session_impl::mutex_t::scoped_lock l1(m_ses->m_mutex);
-		mutex::scoped_lock l2(m_chk->m_mutex);
+		boost::mutex::scoped_lock l2(m_chk->m_mutex);
 		find_torrent(m_ses, m_chk, m_info_hash)->set_max_uploads(max_uploads);
 	}
 
@@ -139,7 +138,7 @@
 		INVARIANT_CHECK;
 
 		session_impl::mutex_t::scoped_lock l1(m_ses->m_mutex);
-		mutex::scoped_lock l2(m_chk->m_mutex);
+		boost::mutex::scoped_lock l2(m_chk->m_mutex);
 		find_torrent(m_ses, m_chk, m_info_hash)->use_interface(net_interface);
 	}
 
@@ -150,7 +149,7 @@
 		assert(max_connections >= 2 || max_connections == -1);
 
 		session_impl::mutex_t::scoped_lock l1(m_ses->m_mutex);
-		mutex::scoped_lock l2(m_chk->m_mutex);
+		boost::mutex::scoped_lock l2(m_chk->m_mutex);
 		find_torrent(m_ses, m_chk, m_info_hash)->set_max_connections(max_connections);
 	}
 
@@ -160,7 +159,7 @@
 		assert(limit >= -1);
 
 		session_impl::mutex_t::scoped_lock l1(m_ses->m_mutex);
-		mutex::scoped_lock l2(m_chk->m_mutex);
+		boost::mutex::scoped_lock l2(m_chk->m_mutex);
 		find_torrent(m_ses, m_chk, m_info_hash)->set_peer_upload_limit(ip, limit);
 	}
 
@@ -170,7 +169,7 @@
 		assert(limit >= -1);
 
 		session_impl::mutex_t::scoped_lock l1(m_ses->m_mutex);
-		mutex::scoped_lock l2(m_chk->m_mutex);
+		boost::mutex::scoped_lock l2(m_chk->m_mutex);
 		find_torrent(m_ses, m_chk, m_info_hash)->set_peer_download_limit(ip, limit);
 	}
 
@@ -181,7 +180,7 @@
 		assert(limit >= -1);
 
 		session_impl::mutex_t::scoped_lock l1(m_ses->m_mutex);
-		mutex::scoped_lock l2(m_chk->m_mutex);
+		boost::mutex::scoped_lock l2(m_chk->m_mutex);
 		find_torrent(m_ses, m_chk, m_info_hash)->set_upload_limit(limit);
 	}
 
@@ -189,7 +188,7 @@
 	{
 		INVARIANT_CHECK;
 		session_impl::mutex_t::scoped_lock l1(m_ses->m_mutex);
-		mutex::scoped_lock l2(m_chk->m_mutex);
+		boost::mutex::scoped_lock l2(m_chk->m_mutex);
 		return find_torrent(m_ses, m_chk, m_info_hash)->upload_limit();
 	}
 
@@ -200,7 +199,7 @@
 		assert(limit >= -1);
 
 		session_impl::mutex_t::scoped_lock l1(m_ses->m_mutex);
-		mutex::scoped_lock l2(m_chk->m_mutex);
+		boost::mutex::scoped_lock l2(m_chk->m_mutex);
 		find_torrent(m_ses, m_chk, m_info_hash)->set_download_limit(limit);
 	}
 
@@ -209,7 +208,7 @@
 		INVARIANT_CHECK;
 
 		session_impl::mutex_t::scoped_lock l1(m_ses->m_mutex);
-		mutex::scoped_lock l2(m_chk->m_mutex);
+		boost::mutex::scoped_lock l2(m_chk->m_mutex);
 		return find_torrent(m_ses, m_chk, m_info_hash)->download_limit();
 	}
 
@@ -219,7 +218,7 @@
 		INVARIANT_CHECK;
 
 		session_impl::mutex_t::scoped_lock l1(m_ses->m_mutex);
-		mutex::scoped_lock l2(m_chk->m_mutex);
+		boost::mutex::scoped_lock l2(m_chk->m_mutex);
 		find_torrent(m_ses, m_chk, m_info_hash)->move_storage(save_path);
 	}
 
@@ -228,7 +227,7 @@
 		INVARIANT_CHECK;
 
 		session_impl::mutex_t::scoped_lock l1(m_ses->m_mutex);
-		mutex::scoped_lock l2(m_chk->m_mutex);
+		boost::mutex::scoped_lock l2(m_chk->m_mutex);
 		return find_torrent(m_ses, m_chk, m_info_hash)->valid_metadata();
 	}
 
@@ -237,7 +236,7 @@
 		INVARIANT_CHECK;
 
 		session_impl::mutex_t::scoped_lock l1(m_ses->m_mutex);
-		mutex::scoped_lock l2(m_chk->m_mutex);
+		boost::mutex::scoped_lock l2(m_chk->m_mutex);
 		return find_torrent(m_ses, m_chk, m_info_hash)->is_seed();
 	}
 
@@ -246,7 +245,7 @@
 		INVARIANT_CHECK;
 
 		session_impl::mutex_t::scoped_lock l1(m_ses->m_mutex);
-		mutex::scoped_lock l2(m_chk->m_mutex);
+		boost::mutex::scoped_lock l2(m_chk->m_mutex);
 		return find_torrent(m_ses, m_chk, m_info_hash)->is_paused();
 	}
 
@@ -255,7 +254,7 @@
 		INVARIANT_CHECK;
 
 		session_impl::mutex_t::scoped_lock l1(m_ses->m_mutex);
-		mutex::scoped_lock l2(m_chk->m_mutex);
+		boost::mutex::scoped_lock l2(m_chk->m_mutex);
 		find_torrent(m_ses, m_chk, m_info_hash)->pause();
 	}
 
@@ -264,7 +263,7 @@
 		INVARIANT_CHECK;
 
 		session_impl::mutex_t::scoped_lock l1(m_ses->m_mutex);
-		mutex::scoped_lock l2(m_chk->m_mutex);
+		boost::mutex::scoped_lock l2(m_chk->m_mutex);
 		find_torrent(m_ses, m_chk, m_info_hash)->resume();
 	}
 
@@ -274,7 +273,7 @@
 		INVARIANT_CHECK;
 
 		session_impl::mutex_t::scoped_lock l1(m_ses->m_mutex);
-		mutex::scoped_lock l2(m_chk->m_mutex);
+		boost::mutex::scoped_lock l2(m_chk->m_mutex);
 		find_torrent(m_ses, m_chk, m_info_hash)->set_tracker_login(name, password);
 	}
 
@@ -286,7 +285,7 @@
 
 		if (m_chk)
 		{
-			mutex::scoped_lock l(m_chk->m_mutex);
+			boost::mutex::scoped_lock l(m_chk->m_mutex);
 
 			aux::piece_checker_data* d = m_chk->find_torrent(m_info_hash);
 			if (d != 0)
@@ -320,7 +319,7 @@
 
 		if (m_chk)
 		{
-			mutex::scoped_lock l(m_chk->m_mutex);
+			boost::mutex::scoped_lock l(m_chk->m_mutex);
 
 			aux::piece_checker_data* d = m_chk->find_torrent(m_info_hash);
 			if (d != 0)
@@ -356,7 +355,7 @@
 	{
 		INVARIANT_CHECK;
 		session_impl::mutex_t::scoped_lock l1(m_ses->m_mutex);
-		mutex::scoped_lock l2(m_chk->m_mutex);
+		boost::mutex::scoped_lock l2(m_chk->m_mutex);
 		find_torrent(m_ses, m_chk, m_info_hash)->set_sequenced_download_threshold(threshold);
 	}
 
@@ -365,7 +364,7 @@
 		INVARIANT_CHECK;
 
 		session_impl::mutex_t::scoped_lock l1(m_ses->m_mutex);
-		mutex::scoped_lock l2(m_chk->m_mutex);
+		boost::mutex::scoped_lock l2(m_chk->m_mutex);
 		return find_torrent(m_ses, m_chk, m_info_hash)->name();
 	}
 
@@ -375,7 +374,7 @@
 		INVARIANT_CHECK;
 
 		session_impl::mutex_t::scoped_lock l1(m_ses->m_mutex);
-		mutex::scoped_lock l2(m_chk->m_mutex);
+		boost::mutex::scoped_lock l2(m_chk->m_mutex);
 		find_torrent(m_ses, m_chk, m_info_hash)->piece_availability(avail);
 	}
 
@@ -384,7 +383,7 @@
 		INVARIANT_CHECK;
 	
 		session_impl::mutex_t::scoped_lock l1(m_ses->m_mutex);
-		mutex::scoped_lock l2(m_chk->m_mutex);
+		boost::mutex::scoped_lock l2(m_chk->m_mutex);
 		find_torrent(m_ses, m_chk, m_info_hash)->set_piece_priority(index, priority);
 	}
 
@@ -393,7 +392,7 @@
 		INVARIANT_CHECK;
 	
 		session_impl::mutex_t::scoped_lock l1(m_ses->m_mutex);
-		mutex::scoped_lock l2(m_chk->m_mutex);
+		boost::mutex::scoped_lock l2(m_chk->m_mutex);
 		return find_torrent(m_ses, m_chk, m_info_hash)->piece_priority(index);
 	}
 
@@ -402,7 +401,7 @@
 		INVARIANT_CHECK;
 
 		session_impl::mutex_t::scoped_lock l1(m_ses->m_mutex);
-		mutex::scoped_lock l2(m_chk->m_mutex);
+		boost::mutex::scoped_lock l2(m_chk->m_mutex);
 		find_torrent(m_ses, m_chk, m_info_hash)->prioritize_pieces(pieces);
 	}
 
@@ -411,7 +410,7 @@
 		INVARIANT_CHECK;
 		std::vector<int> ret;
 		session_impl::mutex_t::scoped_lock l1(m_ses->m_mutex);
-		mutex::scoped_lock l2(m_chk->m_mutex);
+		boost::mutex::scoped_lock l2(m_chk->m_mutex);
 		find_torrent(m_ses, m_chk, m_info_hash)->piece_priorities(ret);
 		return ret;
 	}
@@ -421,7 +420,7 @@
 		INVARIANT_CHECK;
 	
 		session_impl::mutex_t::scoped_lock l1(m_ses->m_mutex);
-		mutex::scoped_lock l2(m_chk->m_mutex);
+		boost::mutex::scoped_lock l2(m_chk->m_mutex);
 		find_torrent(m_ses, m_chk, m_info_hash)->prioritize_files(files);
 	}
 
@@ -431,7 +430,7 @@
 	{
 		INVARIANT_CHECK;
 		session_impl::mutex_t::scoped_lock l1(m_ses->m_mutex);
-		mutex::scoped_lock l2(m_chk->m_mutex);
+		boost::mutex::scoped_lock l2(m_chk->m_mutex);
 		find_torrent(m_ses, m_chk, m_info_hash)->filter_piece(index, filter);
 	}
 
@@ -439,7 +438,7 @@
 	{
 		INVARIANT_CHECK;
 		session_impl::mutex_t::scoped_lock l1(m_ses->m_mutex);
-		mutex::scoped_lock l2(m_chk->m_mutex);
+		boost::mutex::scoped_lock l2(m_chk->m_mutex);
 		find_torrent(m_ses, m_chk, m_info_hash)->filter_pieces(pieces);
 	}
 
@@ -447,7 +446,7 @@
 	{
 		INVARIANT_CHECK;
 		session_impl::mutex_t::scoped_lock l1(m_ses->m_mutex);
-		mutex::scoped_lock l2(m_chk->m_mutex);
+		boost::mutex::scoped_lock l2(m_chk->m_mutex);
 		return find_torrent(m_ses, m_chk, m_info_hash)->is_piece_filtered(index);
 	}
 
@@ -456,7 +455,7 @@
 		INVARIANT_CHECK;
 		std::vector<bool> ret;
 		session_impl::mutex_t::scoped_lock l1(m_ses->m_mutex);
-		mutex::scoped_lock l2(m_chk->m_mutex);
+		boost::mutex::scoped_lock l2(m_chk->m_mutex);
 		find_torrent(m_ses, m_chk, m_info_hash)->filtered_pieces(ret);
 		return ret;
 	}
@@ -465,7 +464,7 @@
 	{
 		INVARIANT_CHECK;
 		session_impl::mutex_t::scoped_lock l1(m_ses->m_mutex);
-		mutex::scoped_lock l2(m_chk->m_mutex);
+		boost::mutex::scoped_lock l2(m_chk->m_mutex);
 		find_torrent(m_ses, m_chk, m_info_hash)->filter_files(files);
 	}
 
@@ -477,7 +476,7 @@
 		INVARIANT_CHECK;
 
 		session_impl::mutex_t::scoped_lock l1(m_ses->m_mutex);
-		mutex::scoped_lock l2(m_chk->m_mutex);
+		boost::mutex::scoped_lock l2(m_chk->m_mutex);
 		return find_torrent(m_ses, m_chk, m_info_hash)->trackers();
 	}
 
@@ -486,7 +485,7 @@
 		INVARIANT_CHECK;
 
 		session_impl::mutex_t::scoped_lock l1(m_ses->m_mutex);
-		mutex::scoped_lock l2(m_chk->m_mutex);
+		boost::mutex::scoped_lock l2(m_chk->m_mutex);
 		find_torrent(m_ses, m_chk, m_info_hash)->add_url_seed(url);
 	}
 
@@ -495,7 +494,7 @@
 		INVARIANT_CHECK;
 
 		session_impl::mutex_t::scoped_lock l1(m_ses->m_mutex);
-		mutex::scoped_lock l2(m_chk->m_mutex);
+		boost::mutex::scoped_lock l2(m_chk->m_mutex);
 		find_torrent(m_ses, m_chk, m_info_hash)->remove_url_seed(url);
 	}
 
@@ -504,7 +503,7 @@
 		INVARIANT_CHECK;
 
 		session_impl::mutex_t::scoped_lock l1(m_ses->m_mutex);
-		mutex::scoped_lock l2(m_chk->m_mutex);
+		boost::mutex::scoped_lock l2(m_chk->m_mutex);
 		return find_torrent(m_ses, m_chk, m_info_hash)->url_seeds();
 	}
 
@@ -514,7 +513,7 @@
 		INVARIANT_CHECK;
 
 		session_impl::mutex_t::scoped_lock l1(m_ses->m_mutex);
-		mutex::scoped_lock l2(m_chk->m_mutex);
+		boost::mutex::scoped_lock l2(m_chk->m_mutex);
 		find_torrent(m_ses, m_chk, m_info_hash)->replace_trackers(urls);
 	}
 
@@ -522,7 +521,7 @@
 	{
 		INVARIANT_CHECK;
 		session_impl::mutex_t::scoped_lock l1(m_ses->m_mutex);
-		mutex::scoped_lock l2(m_chk->m_mutex);
+		boost::mutex::scoped_lock l2(m_chk->m_mutex);
 		boost::shared_ptr<torrent> t = find_torrent(m_ses, m_chk, m_info_hash);
 		if (!t->valid_metadata()) throw_invalid_handle();
 		return t->torrent_file();
@@ -536,7 +535,7 @@
 
 		if (m_chk)
 		{
-			mutex::scoped_lock l(m_chk->m_mutex);
+			boost::mutex::scoped_lock l(m_chk->m_mutex);
 			aux::piece_checker_data* d = m_chk->find_torrent(m_info_hash);
 			if (d != 0) return true;
 		}
@@ -675,7 +674,7 @@
 		INVARIANT_CHECK;
 
 		session_impl::mutex_t::scoped_lock l1(m_ses->m_mutex);
-		mutex::scoped_lock l2(m_chk->m_mutex);
+		boost::mutex::scoped_lock l2(m_chk->m_mutex);
 		return find_torrent(m_ses, m_chk, m_info_hash)->save_path();
 	}
 
@@ -693,7 +692,7 @@
 			// the torrent is being checked. Add the peer to its
 			// peer list. The entries in there will be connected
 			// once the checking is complete.
-			mutex::scoped_lock l2(m_chk->m_mutex);
+			boost::mutex::scoped_lock l2(m_chk->m_mutex);
 
 			aux::piece_checker_data* d = m_chk->find_torrent(m_info_hash);
 			if (d == 0) throw_invalid_handle();
@@ -744,7 +743,7 @@
 			ratio = 1.f;
 
 		session_impl::mutex_t::scoped_lock l1(m_ses->m_mutex);
-		mutex::scoped_lock l2(m_chk->m_mutex);
+		boost::mutex::scoped_lock l2(m_chk->m_mutex);
 		find_torrent(m_ses, m_chk, m_info_hash)->set_ratio(ratio);
 	}
 
@@ -753,7 +752,7 @@
 	{
 		INVARIANT_CHECK;
 		session_impl::mutex_t::scoped_lock l1(m_ses->m_mutex);
-		mutex::scoped_lock l2(m_chk->m_mutex);
+		boost::mutex::scoped_lock l2(m_chk->m_mutex);
 		find_torrent(m_ses, m_chk, m_info_hash)->resolve_countries(r);
 	}
 
@@ -761,7 +760,7 @@
 	{
 		INVARIANT_CHECK;
 		session_impl::mutex_t::scoped_lock l1(m_ses->m_mutex);
-		mutex::scoped_lock l2(m_chk->m_mutex);
+		boost::mutex::scoped_lock l2(m_chk->m_mutex);
 		return find_torrent(m_ses, m_chk, m_info_hash)->resolving_countries();
 	}
 #endif
diff -ru deluge-0.5.5.orig/libtorrent/src/udp_tracker_connection.cpp deluge-0.5.5/libtorrent/src/udp_tracker_connection.cpp
--- deluge-0.5.5.orig/libtorrent/src/udp_tracker_connection.cpp	2007年  9月  3日 一 03:14:45
+++ deluge-0.5.5/libtorrent/src/udp_tracker_connection.cpp	2007年  9月 17日 一 00:49:37
@@ -175,7 +175,7 @@
 		char* ptr = send_buf;
 
 		if (m_transaction_id == 0)
-			m_transaction_id = rand() ^ (rand() << 16);
+			m_transaction_id = std::rand() ^ (std::rand() << 16);
 
 		// connection_id
 		detail::write_uint32(0x417, ptr);
@@ -279,7 +279,7 @@
 	void udp_tracker_connection::send_udp_announce()
 	{
 		if (m_transaction_id == 0)
-			m_transaction_id = rand() ^ (rand() << 16);
+			m_transaction_id = std::rand() ^ (std::rand() << 16);
 
 		if (!m_socket) return; // the operation was aborted
 
@@ -338,7 +338,7 @@
 	void udp_tracker_connection::send_udp_scrape()
 	{
 		if (m_transaction_id == 0)
-			m_transaction_id = rand() ^ (rand() << 16);
+			m_transaction_id = std::rand() ^ (std::rand() << 16);
 
 		if (!m_socket) return; // the operation was aborted
 
diff -ru deluge-0.5.5.orig/libtorrent/src/upnp.cpp deluge-0.5.5/libtorrent/src/upnp.cpp
--- deluge-0.5.5.orig/libtorrent/src/upnp.cpp	2007年  9月 17日 一 01:06:32
+++ deluge-0.5.5/libtorrent/src/upnp.cpp	2007年  9月 17日 一 00:49:37
@@ -618,7 +618,7 @@
 		if (type == xml_start_tag)
 		{
 			if ((!state.top_tag.empty() && state.top_tag == "service")
-				|| !strcmp(string, "service"))
+				|| !std::strcmp(string, "service"))
 			{
 				state.top_tag = string;
 			}
@@ -625,7 +625,7 @@
 		}
 		else if (type == xml_end_tag)
 		{
-			if (!strcmp(string, "service"))
+			if (!std::strcmp(string, "service"))
 			{
 				state.top_tag.clear();
 				if (state.found_service) state.exit = true;
@@ -637,7 +637,7 @@
 		{
 			if (state.top_tag == "serviceType")
 			{
-				if (!strcmp(string, state.service_type))
+				if (!std::strcmp(string, state.service_type))
 					state.found_service = true;
 			}
 			else if (state.top_tag == "controlURL")
@@ -752,7 +752,7 @@
 	void find_error_code(int type, char const* string, error_code_parse_state& state)
 	{
 		if (state.exit) return;
-		if (type == xml_start_tag && !strcmp("errorCode", string))
+		if (type == xml_start_tag && !std::strcmp("errorCode", string))
 		{
 			state.in_error_code = true;
 		}
diff -ru deluge-0.5.5.orig/libtorrent/src/kademlia/node.cpp deluge-0.5.5/libtorrent/src/kademlia/node.cpp
--- deluge-0.5.5.orig/libtorrent/src/kademlia/node.cpp	2007年  9月 17日 一 01:06:32
+++ deluge-0.5.5/libtorrent/src/kademlia/node.cpp	2007年  9月 17日 一 00:49:37
@@ -420,7 +420,7 @@
 	int num = (std::min)((int)v.peers.size(), m_settings.max_peers_reply);
 	peers.clear();
 	peers.reserve(num);
-	random_sample_n(boost::make_transform_iterator(v.peers.begin(), &get_endpoint)
+	std::random_sample_n(boost::make_transform_iterator(v.peers.begin(), &get_endpoint)
 		, boost::make_transform_iterator(v.peers.end(), &get_endpoint)
 		, std::back_inserter(peers), num);
 
diff -ru deluge-0.5.5.orig/libtorrent/src/kademlia/rpc_manager.cpp deluge-0.5.5/libtorrent/src/kademlia/rpc_manager.cpp
--- deluge-0.5.5.orig/libtorrent/src/kademlia/rpc_manager.cpp	2007年  9月 17日 一 01:06:06
+++ deluge-0.5.5/libtorrent/src/kademlia/rpc_manager.cpp	2007年  9月 17日 一 00:49:37
@@ -82,7 +82,7 @@
 	if (--o->m_refs == 0)
 	{
 		boost::pool<>& p = o->pool_allocator;
-		o->~observer();
+		(const_cast<observer*>(o))->~observer();
 		p.ordered_free(const_cast<observer*>(o));
 	}
 }
@@ -106,7 +106,7 @@
 rpc_manager::rpc_manager(fun const& f, node_id const& our_id
 	, routing_table& table, send_fun const& sf)
 	: m_pool_allocator(sizeof(mpl::deref<max_observer_type_iter::base>::type))
-	, m_next_transaction_id(rand() % max_transactions)
+	, m_next_transaction_id(std::rand() % max_transactions)
 	, m_oldest_transaction_id(m_next_transaction_id)
 	, m_incoming(f)
 	, m_send(sf)
