Index: trunk/manuals/reference/libanjuta/writing-plugins-vala.sgml
===================================================================
--- trunk/manuals/reference/libanjuta/writing-plugins-vala.sgml	(revision 0)
+++ trunk/manuals/reference/libanjuta/writing-plugins-vala.sgml	(revision 4066)
@@ -0,0 +1,134 @@
+<chapter id="writing-plugins-vala">
+  <title>Writing plugins in Vala</title>
+  <para>
+    Before writing an Anjuta plugin, please read
+    <xref linkend="anjuta-architecture"/> for general concepts about how Anjuta 
+    plugins interact with Anjuta Shell and other plugins.
+  </para>
+  <para>
+    Anjuta API is divided in two namespaces : Anjuta and IAnjuta. Anjuta
+    contains API to interact with the IDE, and IAnjuta contains interfaces that
+    plugins implement to be able to interact with each other.
+    Writing a plugin for Anjuta is as simple as subclassing Anjuta.Plugin,
+    overriding activate and deactivate, and writing a .plugin file to let Anjuta
+    know about your plugin.
+  </para>
+  <para>
+    This tutorial is still uncomplete. However most of the documentation
+    regarding C plugins is still applicable, so you can always refer to
+    <xref linkend="writing-plugins">it</xref>.
+  </para>
+  <para>
+    In this tutorial, we will write a basic <emphasis>Hello world</emphasis>
+    plugin that does nothing but adding a "Hello World" label to Anjuta.
+  </para>
+  <sect1 id="writing-code">
+    <title> Writing the plugin code </title>
+    <para>
+      As said earlier, we will need to subclass Anjuta.Plugin and override some
+      methods, so here is Anjuta.Plugin :
+      <programlisting>
+public class Anjuta.Plugin : GLib.Object {
+        public uint add_watch (string name, Anjuta.PluginValueAdded added, Anjuta.PluginValueRemoved removed);
+        public bool is_active ();
+        public void remove_watch (uint id, bool send_remove);
+        public virtual bool activate ();
+        public virtual bool deactivate ();
+        public weak Anjuta.Shell shell { get; set; }
+        public signal void activated ();
+        public signal void deactivated ();
+}
+      </programlisting>
+      The methods we'll need to override are activate and deactivate, the shell
+      property is what we'll use to interact with Anjuta. <methodname>add_watch</methodname>
+      and <methodname>remove_watch</methodname> are used to interface with the
+      <emphasis>Values System</emphasis> see <xref linkend="anjuta-architecture"/>
+      for more information. The rest is pretty self explanatory, and we generally won't need it.
+    </para>
+    <para>
+      We will only use the <methodname>add_widget</methodname> method of 
+      <type>Anjuta.Shell</type> in this tutorial. For more informations, you can see
+      the <link linkend="AnjutaShell">C API documentation</link>.
+    </para>
+    <para>
+      This plugin does nothing more than showing a "Hello World" widget in
+      Anjuta 
+    </para>
+      <programlisting>
+using Gtk;
+using Anjuta;
+
+public class HelloWorldPlugin: Plugin {
+    /* The hello world widget */
+    Widget widget;
+
+    /* We use the "override" keyword to override the virtual methods activate and deactivate */
+    public override bool activate () {
+        widget = new Label("Hello World");
+
+        /* adding the widget */
+        shell.add_widget(widget, /* the widget to add */
+                         "AnjutaHelloWorldPlugin", /* name of the widget*/
+                         "HelloWorldPlugin", /* title, should be translated */
+                         Gtk.STOCK_ABOUT, /* icon stock id */
+                         ShellPlacement.CENTER); /* placement in in the shell */
+        return true; /* false if activation failed */
+    }
+
+    public override bool deactivate () {
+        /* remove the widget we've added */
+        shell.remove_widget(widget);
+
+        return true; /* false if plugin doesn't want to deactivate */
+    }
+}
+
+/* Initialization function, in C this would be automatically generated by the
+   ANJUTA_SIMPLE_PLUGIN macro */
+[ModuleInit]
+public GLib.Type anjuta_glue_register_components (GLib.TypeModule module) {
+    return typeof (HelloWorldPlugin);
+}
+      </programlisting>
+  </sect1>
+  <sect1>
+    <title>Writing a plugin description</title>
+    Anjuta needs a file with a plugin extension to know about our plugin, its name
+    and description, where it is located, when to load it. Here is an example for our
+    basic plugin :
+    <programlisting>
+[Anjuta Plugin]
+Name=Hello World
+Description=An example hello world plugin.
+Location=anjuta-hello-world:HelloWorldPlugin
+Icon=anjuta-sample-plugin-48.png
+    </programlisting>
+    Generally, Name and Description should be translated. Using intltool, you can
+    do this by prefixing them with _.
+    Location is of the form libraryname:ClassName : libraryname is the name of the
+    library file (without the lib prefix and .so suffix), and ClassName is the full
+    class name including the namespace (and not separated by a period as you would 
+    write it in Vala).
+    Icon is the icon to be used by the plugin, here we put sample plugin icon which
+    is distributed along with Anjuta, but you could put your own icon instead.
+    <para>
+      For more information about plugin description files, refer to
+      <xref linkend="plugin-description-file"/>.
+    </para>
+  </sect1>
+  <sect1>
+    <title>Compiling and installing the plugin</title>
+    <sect2>
+      <title>Manual compilation</title>
+      Assuming you saved the plugin as hello-plugin.vala, you can compile it with :
+      <userinput>
+valac --ccode --pkg libanjuta-1.0 hello-plugin.vala
+gcc -shared -o libanjuta-hello-world.so
+      </userinput>
+    </sect2>
+    <sect2>
+      <title>Using autotools</title>
+      Coming soon.
+    </sect2>
+  </sect1>    
+</chapter>
