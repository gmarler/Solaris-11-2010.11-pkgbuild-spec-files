diff --git a/JavaScriptCore/runtime/Structure.cpp b/JavaScriptCore/runtime/Structure.cpp
index 2c577dc..bb08f26 100644
--- a/JavaScriptCore/runtime/Structure.cpp
+++ b/JavaScriptCore/runtime/Structure.cpp
@@ -158,7 +158,7 @@ Structure::~Structure()
 {
     if (m_previous) {
         if (m_nameInPrevious)
-            m_previous->table.remove(make_pair(m_nameInPrevious.get(), m_attributesInPrevious), m_specificValueInPrevious);
+            m_previous->table.remove(std::make_pair<RefPtr<UString::Rep>,unsigned>(m_nameInPrevious.get(), m_attributesInPrevious), m_specificValueInPrevious);
         else
             m_previous->table.removeAnonymousSlotTransition(m_anonymousSlotsInPrevious);
 
@@ -345,7 +345,7 @@ PassRefPtr<Structure> Structure::addPropertyTransitionToExistingStructure(Struct
     ASSERT(!structure->isDictionary());
     ASSERT(structure->typeInfo().type() == ObjectType);
 
-    if (Structure* existingTransition = structure->table.get(make_pair(propertyName.ustring().rep(), attributes), specificValue)) {
+    if (Structure* existingTransition = structure->table.get(make_pair<RefPtr<UString::Rep>, unsigned>(propertyName.ustring().rep(), attributes), specificValue)) {
         ASSERT(existingTransition->m_offset != noOffset);
         offset = existingTransition->m_offset;
         return existingTransition;
@@ -404,7 +404,7 @@ PassRefPtr<Structure> Structure::addPropertyTransition(Structure* structure, con
 
     transition->m_offset = offset;
 
-    structure->table.add(make_pair(propertyName.ustring().rep(), attributes), transition.get(), specificValue);
+    structure->table.add(make_pair<RefPtr<UString::Rep>, unsigned>(propertyName.ustring().rep(), attributes), transition.get(), specificValue);
     return transition.release();
 }
 
@@ -889,7 +889,7 @@ void Structure::addAnonymousSlots(unsigned count)
 
 bool Structure::hasTransition(UString::Rep* rep, unsigned attributes)
 {
-    return table.hasTransition(make_pair(rep, attributes));
+    return table.hasTransition(make_pair<RefPtr<UString::Rep>, unsigned>(rep, attributes));
 }
 
 size_t Structure::remove(const Identifier& propertyName)
diff --git a/JavaScriptCore/runtime/Structure.h b/JavaScriptCore/runtime/Structure.h
index 4cbe6ff..ea000be 100644
--- a/JavaScriptCore/runtime/Structure.h
+++ b/JavaScriptCore/runtime/Structure.h
@@ -317,7 +317,7 @@ namespace JSC {
         TransitionTable* transitionTable = new TransitionTable;
         setTransitionTable(transitionTable);
         if (existingTransition)
-            add(std::make_pair(existingTransition->m_nameInPrevious.get(), existingTransition->m_attributesInPrevious), existingTransition, existingTransition->m_specificValueInPrevious);
+            add(std::make_pair<WTF::RefPtr<UString::Rep>,unsigned>(existingTransition->m_nameInPrevious.get(), existingTransition->m_attributesInPrevious), existingTransition, existingTransition->m_specificValueInPrevious);
     }
 } // namespace JSC
 
diff --git a/JavaScriptCore/wtf/HashMap.h b/JavaScriptCore/wtf/HashMap.h
index ece3812..c36b91f 100644
--- a/JavaScriptCore/wtf/HashMap.h
+++ b/JavaScriptCore/wtf/HashMap.h
@@ -235,7 +235,8 @@ namespace WTF {
     HashMap<T, U, V, W, X>::inlineAdd(const KeyType& key, const MappedType& mapped) 
     {
         typedef HashMapTranslator<ValueType, ValueTraits, HashFunctions> TranslatorType;
-        return m_impl.template add<KeyType, MappedType, TranslatorType>(key, mapped);
+        pair<typename HashTableType::iterator, bool> p = m_impl.template add<KeyType, MappedType, TranslatorType>(key, mapped);
+        return make_pair<typename HashMap<T, U, V, W, X>::iterator, bool>(p.first, p.second);
     }
 
     template<typename T, typename U, typename V, typename W, typename X>
@@ -256,7 +257,8 @@ namespace WTF {
     HashMap<T, U, V, W, X>::add(const TYPE& key, const MappedType& value)
     {
         typedef HashMapTranslatorAdapter<ValueType, ValueTraits, TYPE, HashTranslator> Adapter;
-        return m_impl.template addPassingHashCode<TYPE, MappedType, Adapter>(key, value);
+        pair<typename HashTableType::iterator, bool> p = m_impl.template addPassingHashCode<TYPE, MappedType, Adapter>(key, value);
+        return make_pair<typename HashMap<T, U, V, W, X>::iterator, bool>(p.first, p.second);
     }
 
     template<typename T, typename U, typename V, typename W, typename X>
diff --git a/JavaScriptCore/wtf/HashSet.h b/JavaScriptCore/wtf/HashSet.h
index 0d7b4bb..1779212 100644
--- a/JavaScriptCore/wtf/HashSet.h
+++ b/JavaScriptCore/wtf/HashSet.h
@@ -207,7 +207,8 @@ namespace WTF {
     template<typename T, typename U, typename V>
     pair<typename HashSet<T, U, V>::iterator, bool> HashSet<T, U, V>::add(const ValueType& value)
     {
-        return m_impl.add(value);
+	pair<typename HashTable<T, T, IdentityExtractor<T>, U, V, V>::iterator, bool> p = m_impl.add(value);
+	return make_pair<typename HashSet<T, U, V>::iterator, bool>(p.first, p.second);
     }
 
     template<typename Value, typename HashFunctions, typename Traits>
@@ -216,7 +217,8 @@ namespace WTF {
     HashSet<Value, HashFunctions, Traits>::add(const T& value)
     {
         typedef HashSetTranslatorAdapter<ValueType, ValueTraits, T, HashTranslator> Adapter;
-        return m_impl.template addPassingHashCode<T, T, Adapter>(value, value);
+	pair<typename HashTableType::iterator, bool> p = m_impl.template addPassingHashCode<T, T, Adapter>(value, value);
+	return make_pair<iterator, bool>(p.first, p.second);
     }
 
     template<typename T, typename U, typename V>
diff --git a/JavaScriptCore/wtf/RefPtrHashMap.h b/JavaScriptCore/wtf/RefPtrHashMap.h
index 9433025..3b68439 100644
--- a/JavaScriptCore/wtf/RefPtrHashMap.h
+++ b/JavaScriptCore/wtf/RefPtrHashMap.h
@@ -205,14 +205,16 @@ namespace WTF {
     HashMap<RefPtr<T>, U, V, W, X>::inlineAdd(const KeyType& key, const MappedType& mapped) 
     {
         typedef HashMapTranslator<ValueType, ValueTraits, HashFunctions> TranslatorType;
-        return m_impl.template add<KeyType, MappedType, TranslatorType>(key, mapped);
+        pair<typename HashTableType::iterator, bool> p = m_impl.template add<KeyType, MappedType, TranslatorType>(key, mapped);
+        return make_pair<typename HashMap<RefPtr<T>, U, V, W, X>::iterator, bool>(p.first, p.second);
     }
 
     template<typename T, typename U, typename V, typename W, typename X>
     inline pair<typename HashMap<RefPtr<T>, U, V, W, X>::iterator, bool>
     HashMap<RefPtr<T>, U, V, W, X>::inlineAdd(RawKeyType key, const MappedType& mapped) 
     {
-        return m_impl.template add<RawKeyType, MappedType, RawKeyTranslator>(key, mapped);
+        pair<typename HashTableType::iterator, bool> p = m_impl.template add<RawKeyType, MappedType, RawKeyTranslator>(key, mapped);
+        return make_pair<typename HashMap<RefPtr<T>, U, V, W, X>::iterator, bool>(p.first, p.second);
     }
 
     template<typename T, typename U, typename V, typename W, typename X>
