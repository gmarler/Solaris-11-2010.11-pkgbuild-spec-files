--- wine-0.9.61.orig/dlls/gdiplus/image.c	2008-05-02 10:01:51.000000000 -0700
+++ wine-0.9.61/dlls/gdiplus/image.c	2008-05-03 12:03:04.360774090 -0700
@@ -36,12 +36,12 @@
 
 #define PIXELFORMATBPP(x) ((x) ? ((x) >> 8) & 255 : 24)
 
-static INT ipicture_pixel_height(IPicture *pic)
+static INT ipicture_pixel_height(IPicture *pict)
 {
     HDC hdcref;
     OLE_YSIZE_HIMETRIC y;
 
-    IPicture_get_Height(pic, &y);
+    IPicture_get_Height(pict, &y);
 
     hdcref = GetDC(0);
 
@@ -51,12 +51,12 @@
     return y;
 }
 
-static INT ipicture_pixel_width(IPicture *pic)
+static INT ipicture_pixel_width(IPicture *pict)
 {
     HDC hdcref;
     OLE_XSIZE_HIMETRIC x;
 
-    IPicture_get_Width(pic, &x);
+    IPicture_get_Width(pict, &x);
 
     hdcref = GetDC(0);
 
@@ -728,19 +728,19 @@
 
 GpStatus WINGDIPAPI GdipLoadImageFromStream(IStream* stream, GpImage **image)
 {
-    IPicture *pic;
+    IPicture *pict;
     short type;
 
     if(!stream || !image)
         return InvalidParameter;
 
     if(OleLoadPicture(stream, 0, FALSE, &IID_IPicture,
-        (LPVOID*) &pic) != S_OK){
+        (LPVOID*) &pict) != S_OK){
         TRACE("Could not load picture\n");
         return GenericError;
     }
 
-    IPicture_get_Type(pic, &type);
+    IPicture_get_Type(pict, &type);
 
     if(type == PICTYPE_BITMAP){
         BITMAPINFO bmi;
@@ -752,12 +752,12 @@
         if(!*image) return OutOfMemory;
         (*image)->type = ImageTypeBitmap;
 
-        (*((GpBitmap**) image))->width = ipicture_pixel_width(pic);
-        (*((GpBitmap**) image))->height = ipicture_pixel_height(pic);
+        (*((GpBitmap**) image))->width = ipicture_pixel_width(pict);
+        (*((GpBitmap**) image))->height = ipicture_pixel_height(pict);
 
         /* get the pixel format */
-        IPicture_get_Handle(pic, &hbm);
-        IPicture_get_CurDC(pic, &hdc);
+        IPicture_get_Handle(pict, &hbm);
+        IPicture_get_CurDC(pict, &hdc);
 
         ZeroMemory(&bmi, sizeof(bmi));
         bmch = (BITMAPCOREHEADER*) (&bmi.bmiHeader);
@@ -788,7 +788,7 @@
         (*image)->type = ImageTypeUnknown;
     }
 
-    (*image)->picture = pic;
+    (*image)->picture = pict;
 
     return Ok;
 }
--- wine-0.9.61.orig/dlls/msi/dialog.c	2008-05-02 10:01:51.000000000 -0700
+++ wine-0.9.61/dlls/msi/dialog.c	2008-05-03 11:58:32.100659368 -0700
@@ -1067,7 +1067,7 @@
     HBITMAP hOleBitmap = 0, hBitmap = 0, hOldSrcBitmap, hOldDestBitmap;
     MSIRECORD *rec = NULL;
     IStream *stm = NULL;
-    IPicture *pic = NULL;
+    IPicture *picture = NULL;
     HDC srcdc, destdc;
     BITMAP bm;
     UINT r;
@@ -1081,7 +1081,7 @@
     if( r != ERROR_SUCCESS )
         goto end;
 
-    r = OleLoadPicture( stm, 0, TRUE, &IID_IPicture, (LPVOID*) &pic );
+    r = OleLoadPicture( stm, 0, TRUE, &IID_IPicture, (LPVOID*) &picture );
     IStream_Release( stm );
     if( FAILED( r ) )
     {
@@ -1089,7 +1089,7 @@
         goto end;
     }
 
-    r = IPicture_get_Handle( pic, (OLE_HANDLE*) &hOleBitmap );
+    r = IPicture_get_Handle( picture, (OLE_HANDLE*) &hOleBitmap );
     if( FAILED( r ) )
     {
         ERR("failed to get bitmap handle\n");
@@ -1123,8 +1123,8 @@
     DeleteDC( destdc );
 
 end:
-    if ( pic )
-        IPicture_Release( pic );
+    if ( picture )
+        IPicture_Release( picture );
     return hBitmap;
 }
 
--- wine-0.9.61.orig/dlls/msrle32/msrle32.c	2008-05-02 10:01:51.000000000 -0700
+++ wine-0.9.61/dlls/msrle32/msrle32.c	2008-05-03 14:08:53.654420035 -0700
@@ -93,7 +93,7 @@
 			       LPCBITMAPINFOHEADER lpbiOut);
 static LRESULT DecompressBegin(CodecInfo *pi, LPCBITMAPINFOHEADER lpbiIn,
 			       LPCBITMAPINFOHEADER lpbiOut);
-static LRESULT Decompress(CodecInfo *pi, ICDECOMPRESS *pic, DWORD dwSize);
+static LRESULT Decompress(CodecInfo *pi, ICDECOMPRESS *lpic, DWORD dwSize);
 static LRESULT DecompressEnd(CodecInfo *pi);
 static LRESULT DecompressGetPalette(CodecInfo *pi, LPCBITMAPINFOHEADER lpbiIn,
 				    LPBITMAPINFOHEADER lpbiOut);
@@ -1711,36 +1711,36 @@
   return ICERR_OK;
 }
 
-static LRESULT Decompress(CodecInfo *pi, ICDECOMPRESS *pic, DWORD dwSize)
+static LRESULT Decompress(CodecInfo *pi, ICDECOMPRESS *lpic, DWORD dwSize)
 {
-  TRACE("(%p,%p,%u)\n",pi,pic,dwSize);
+  TRACE("(%p,%p,%u)\n",pi,lpic,dwSize);
 
   /* pre-condition */
   assert(pi != NULL);
 
   /* check parameters */
-  if (pic == NULL)
+  if (lpic == NULL)
     return ICERR_BADPARAM;
-  if (pic->lpbiInput == NULL || pic->lpInput == NULL ||
-      pic->lpbiOutput == NULL || pic->lpOutput == NULL)
+  if (lpic->lpbiInput == NULL || lpic->lpInput == NULL ||
+      lpic->lpbiOutput == NULL || lpic->lpOutput == NULL)
     return ICERR_BADPARAM;
 
   /* check formats */
   if (! pi->bDecompress) {
-    LRESULT hr = DecompressBegin(pi, pic->lpbiInput, pic->lpbiOutput);
+    LRESULT hr = DecompressBegin(pi, lpic->lpbiInput, lpic->lpbiOutput);
     if (hr != ICERR_OK)
       return hr;
-  } else if (DecompressQuery(pi, pic->lpbiInput, pic->lpbiOutput) != ICERR_OK)
+  } else if (DecompressQuery(pi, lpic->lpbiInput, lpic->lpbiOutput) != ICERR_OK)
     return ICERR_BADFORMAT;
 
-  assert(pic->lpbiInput->biWidth  == pic->lpbiOutput->biWidth);
-  assert(pic->lpbiInput->biHeight == pic->lpbiOutput->biHeight);
+  assert(lpic->lpbiInput->biWidth  == lpic->lpbiOutput->biWidth);
+  assert(lpic->lpbiInput->biHeight == lpic->lpbiOutput->biHeight);
 
-  pic->lpbiOutput->biSizeImage = DIBWIDTHBYTES(*pic->lpbiOutput) * pic->lpbiOutput->biHeight;
-  if (pic->lpbiInput->biBitCount == 4)
-    return MSRLE32_DecompressRLE4(pi, pic->lpbiOutput, pic->lpInput, pic->lpOutput);
+  lpic->lpbiOutput->biSizeImage = DIBWIDTHBYTES(*lpic->lpbiOutput) * lpic->lpbiOutput->biHeight;
+  if (lpic->lpbiInput->biBitCount == 4)
+    return MSRLE32_DecompressRLE4(pi, lpic->lpbiOutput, lpic->lpInput, lpic->lpOutput);
   else
-    return MSRLE32_DecompressRLE8(pi, pic->lpbiOutput, pic->lpInput, pic->lpOutput);
+    return MSRLE32_DecompressRLE8(pi, lpic->lpbiOutput, lpic->lpInput, lpic->lpOutput);
 }
 
 static LRESULT DecompressEnd(CodecInfo *pi)
--- wine-0.9.61.orig/dlls/oleaut32/tests/olepicture.c	2008-05-02 10:01:51.000000000 -0700
+++ wine-0.9.61/dlls/oleaut32/tests/olepicture.c	2008-05-03 14:28:13.190297028 -0700
@@ -136,7 +136,7 @@
 static void
 test_pic_with_stream(LPSTREAM stream, unsigned int imgsize)
 {
-	IPicture*	pic = NULL;
+	IPicture*	pict = NULL;
 	HRESULT		hres;
 	LPVOID		pvObj = NULL;
 	OLE_HANDLE	handle, hPal;
@@ -148,15 +148,15 @@
 
 	pvObj = NULL;
 	hres = pOleLoadPicture(stream, imgsize, TRUE, &IID_IPicture, &pvObj);
-	pic = pvObj;
+	pict = pvObj;
 
 	ok(hres == S_OK,"OLP (NULL,..) does not return 0, but 0x%08x\n",hres);
-	ok(pic != NULL,"OLP (NULL,..) returns NULL, instead of !NULL\n");
-	if (pic == NULL)
+	ok(pict != NULL,"OLP (NULL,..) returns NULL, instead of !NULL\n");
+	if (pict == NULL)
 		return;
 
 	pvObj = NULL;
-	hres = IPicture_QueryInterface (pic, &IID_IPicture, &pvObj);
+	hres = IPicture_QueryInterface (pict, &IID_IPicture, &pvObj);
 
 	ok(hres == S_OK,"IPicture_QI does not return S_OK, but 0x%08x\n", hres);
 	ok(pvObj != NULL,"IPicture_QI does return NULL, instead of a ptr\n");
@@ -164,37 +164,37 @@
 	IPicture_Release ((IPicture*)pvObj);
 
 	handle = 0;
-	hres = IPicture_get_Handle (pic, &handle);
+	hres = IPicture_get_Handle (pict, &handle);
 	ok(hres == S_OK,"IPicture_get_Handle does not return S_OK, but 0x%08x\n", hres);
 	ok(handle != 0, "IPicture_get_Handle returns a NULL handle, but it should be non NULL\n");
 
 	width = 0;
-	hres = IPicture_get_Width (pic, &width);
+	hres = IPicture_get_Width (pict, &width);
 	ok(hres == S_OK,"IPicture_get_Width does not return S_OK, but 0x%08x\n", hres);
 	ok(width != 0, "IPicture_get_Width returns 0, but it should not be 0.\n");
 
 	height = 0;
-	hres = IPicture_get_Height (pic, &height);
+	hres = IPicture_get_Height (pict, &height);
 	ok(hres == S_OK,"IPicture_get_Height does not return S_OK, but 0x%08x\n", hres);
 	ok(height != 0, "IPicture_get_Height returns 0, but it should not be 0.\n");
 
 	type = 0;
-	hres = IPicture_get_Type (pic, &type);
+	hres = IPicture_get_Type (pict, &type);
 	ok(hres == S_OK,"IPicture_get_Type does not return S_OK, but 0x%08x\n", hres);
 	ok(type == PICTYPE_BITMAP, "IPicture_get_Type returns %d, but it should be PICTYPE_BITMAP(%d).\n", type, PICTYPE_BITMAP);
 
 	attr = 0;
-	hres = IPicture_get_Attributes (pic, &attr);
+	hres = IPicture_get_Attributes (pict, &attr);
 	ok(hres == S_OK,"IPicture_get_Attributes does not return S_OK, but 0x%08x\n", hres);
 	ok(attr == 0, "IPicture_get_Attributes returns %d, but it should be 0.\n", attr);
 
 	hPal = 0;
-	hres = IPicture_get_hPal (pic, &hPal);
+	hres = IPicture_get_hPal (pict, &hPal);
 	ok(hres == S_OK,"IPicture_get_hPal does not return S_OK, but 0x%08x\n", hres);
 	/* a single pixel b/w image has no palette */
 	ok(hPal == 0, "IPicture_get_hPal returns %d, but it should be 0.\n", hPal);
 
-	res = IPicture_Release (pic);
+	res = IPicture_Release (pict);
 	ok (res == 0, "refcount after release is %d, but should be 0?\n", res);
 }
 
@@ -269,7 +269,7 @@
 static void test_empty_image(void) {
 	LPBYTE		data;
 	LPSTREAM	stream;
-	IPicture*	pic = NULL;
+	IPicture*	pict = NULL;
 	HRESULT		hres;
 	LPVOID		pvObj = NULL;
 	HGLOBAL		hglob;
@@ -292,24 +292,24 @@
 
 	pvObj = NULL;
 	hres = pOleLoadPicture(stream, 8, TRUE, &IID_IPicture, &pvObj);
-	pic = pvObj;
+	pict = pvObj;
 	ok(hres == S_OK,"empty picture not loaded, hres 0x%08x\n", hres);
-	ok(pic != NULL,"empty picture not loaded, pic is NULL\n");
+	ok(pict != NULL,"empty picture not loaded, pict is NULL\n");
 
-	hres = IPicture_get_Type (pic, &type);
+	hres = IPicture_get_Type (pict, &type);
 	ok (hres == S_OK,"empty picture get type failed with hres 0x%08x\n", hres);
 	ok (type == PICTYPE_NONE,"type is %d, but should be PICTYPE_NONE(0)\n", type);
 
-	hres = IPicture_get_Handle (pic, &handle);
+	hres = IPicture_get_Handle (pict, &handle);
 	ok (hres == S_OK,"empty picture get handle failed with hres 0x%08x\n", hres);
 	ok (handle == 0, "empty picture get handle did not return 0, but 0x%08x\n", handle);
-	IPicture_Release (pic);
+	IPicture_Release (pict);
 }
 
 static void test_empty_image_2(void) {
 	LPBYTE		data;
 	LPSTREAM	stream;
-	IPicture*	pic = NULL;
+	IPicture*	pict = NULL;
 	HRESULT		hres;
 	LPVOID		pvObj = NULL;
 	HGLOBAL		hglob;
@@ -333,15 +333,15 @@
 
 	pvObj = NULL;
 	hres = pOleLoadPicture(stream, 8, TRUE, &IID_IPicture, &pvObj);
-	pic = pvObj;
+	pict = pvObj;
 	ok(hres == S_OK,"empty picture not loaded, hres 0x%08x\n", hres);
-	ok(pic != NULL,"empty picture not loaded, pic is NULL\n");
+	ok(pict != NULL,"empty picture not loaded, pict is NULL\n");
 
-	hres = IPicture_get_Type (pic, &type);
+	hres = IPicture_get_Type (pict, &type);
 	ok (hres == S_OK,"empty picture get type failed with hres 0x%08x\n", hres);
 	ok (type == PICTYPE_NONE,"type is %d, but should be PICTYPE_NONE(0)\n", type);
 
-	IPicture_Release (pic);
+	IPicture_Release (pict);
 }
 
 static void test_Invoke(void)
