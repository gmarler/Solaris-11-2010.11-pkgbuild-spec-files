--- data/gnome-power-manager.schemas.in.org	2007-12-06 18:41:20.547365000 +0800
+++ data/gnome-power-manager.schemas.in	2007-12-05 17:07:50.852423000 +0800
@@ -717,6 +717,94 @@
     </schema>
 
     <schema>
+      <key>/schemas/apps/gnome-power-manager/solaris/sleep_computer_ac</key>
+      <applyto>/apps/gnome-power-manager/solaris/sleep_computer_ac</applyto>
+      <type>int</type>
+      <default>0</default>
+      <locale name="C">
+        <short>Sleep timeout power manageable devices when on AC</short>
+        <long>The amount of time in seconds power manageable devices on AC power needs to be inactive before it goes to sleep.</long>
+      </locale>
+    </schema>
+
+    <schema>
+      <key>/schemas/apps/gnome-power-manager/solaris/sleep_disk_ac</key>
+      <applyto>/apps/gnome-power-manager/solaris/sleep_disk_ac</applyto>
+      <type>int</type>
+      <default>0</default>
+      <locale name="C">
+        <short>Sleep timeout disk when on AC</short>
+        <long>The amount of time in seconds before disk sleep on AC power needs to be inactive before it goes to sleep.</long>
+      </locale>
+    </schema>
+
+    <schema>
+      <key>/schemas/apps/gnome-power-manager/solaris/sleep_suspend_ac</key>
+      <applyto>/apps/gnome-power-manager/solaris/sleep_suspend_ac</applyto>
+      <type>bool</type>
+      <default>0</default>
+      <locale name="C">
+        <short>Whether enable suspend computer when on AC</short>
+        <long>Disable or enable the feature that suspend system on AC power after all power manageable devices go to sleep.</long>
+      </locale>
+    </schema>
+
+    <schema>
+      <key>/schemas/apps/gnome-power-manager/solaris/sleep_hibernate_ac</key>
+      <applyto>/apps/gnome-power-manager/solaris/sleep_hibernate_ac</applyto>
+      <type>int</type>
+      <default>0</default>
+      <locale name="C">
+        <short>Hibernate timeout computer when on AC</short>
+        <long>The amount of time in seconds before hibernating system on AC power needs to be inactive before it goes to sleep.</long>
+      </locale>
+    </schema>
+
+<schema>
+      <key>/schemas/apps/gnome-power-manager/solaris/sleep_computer_battery</key>
+      <applyto>/apps/gnome-power-manager/solaris/sleep_computer_battery</applyto>
+      <type>int</type>
+      <default>0</default>
+      <locale name="C">
+        <short>Sleep timeout power manageable devices when on battery</short>
+        <long>The amount of time in seconds power manageable devices on battery power needs to be inactive before it goes to sleep.</long>
+      </locale>
+    </schema>
+
+    <schema>
+      <key>/schemas/apps/gnome-power-manager/solaris/sleep_disk_battery</key>
+      <applyto>/apps/gnome-power-manager/solaris/sleep_disk_battery</applyto>
+      <type>int</type>
+      <default>0</default>
+      <locale name="C">
+        <short>Sleep timeout disk when on battery</short>
+        <long>The amount of time in seconds before disk sleep on battery power needs to be inactive before it goes to sleep.</long>
+      </locale>
+    </schema>
+
+    <schema>
+      <key>/schemas/apps/gnome-power-manager/solaris/sleep_suspend_battery</key>
+      <applyto>/apps/gnome-power-manager/solaris/sleep_suspend_battery</applyto>
+      <type>bool</type>
+      <default>0</default>
+      <locale name="C">
+        <short>Whether enable suspend computer when on battery</short>
+        <long>Disable or enable the feature that suspend system on battery power after all power manageable devices go to sleep.</long>
+      </locale>
+    </schema>
+
+    <schema>
+      <key>/schemas/apps/gnome-power-manager/solaris/sleep_hibernate_battery</key>
+      <applyto>/apps/gnome-power-manager/solaris/sleep_hibernate_battery</applyto>
+      <type>int</type>
+      <default>0</default>
+      <locale name="C">
+        <short>Hibernate timeout computer when on battery</short>
+        <long>The amount of time in seconds before hibernating system on battery power needs to be inactive before it goes to sleep.</long>
+      </locale>
+    </schema>
+
+    <schema>
       <key>/schemas/apps/gnome-power-manager/statistics/show_axis_labels</key>
       <applyto>/apps/gnome-power-manager/statistics/show_axis_labels</applyto>
       <owner>gnome-power-manager</owner>
--- data/gpm-prefs.glade.org	2007-12-05 23:31:54.605773000 +0800
+++ data/gpm-prefs.glade	2007-12-06 00:03:11.957167000 +0800
@@ -100,7 +100,7 @@
 			      <child>
 				<widget class="GtkLabel" id="label_ac_computer">
 				  <property name="visible">True</property>
-				  <property name="label" translatable="yes">Put computer to _sleep when inactive for:</property>
+				  <property name="label" translatable="yes">Put power manageable devices to _sleep when inactive for:</property>
 				  <property name="use_underline">True</property>
 				  <property name="use_markup">False</property>
 				  <property name="justify">GTK_JUSTIFY_LEFT</property>
@@ -133,7 +133,142 @@
 				  <property name="digits">0</property>
 				  <property name="update_policy">GTK_UPDATE_CONTINUOUS</property>
 				  <property name="inverted">False</property>
-				  <property name="adjustment">1 1 61 1 5 0</property>
+				  <property name="adjustment">0 0 241 1 5 0</property>
+				</widget>
+				<packing>
+				  <property name="padding">0</property>
+				  <property name="expand">True</property>
+				  <property name="fill">True</property>
+				</packing>
+			      </child>
+			    </widget>
+			    <packing>
+			      <property name="padding">0</property>
+			      <property name="expand">False</property>
+			      <property name="fill">False</property>
+			    </packing>
+			  </child>
+
+			  <child>
+			    <widget class="GtkCheckButton" id="checkbutton_ac_suspend">
+			      <property name="visible">True</property>
+			      <property name="can_focus">True</property>
+			      <property name="label" translatable="yes">_Suspend computer when inactive for:</property>
+			      <property name="use_underline">True</property>
+			      <property name="relief">GTK_RELIEF_NORMAL</property>
+			      <property name="focus_on_click">True</property>
+			      <property name="active">False</property>
+			      <property name="inconsistent">False</property>
+			      <property name="draw_indicator">True</property>
+			    </widget>
+			    <packing>
+			      <property name="padding">0</property>
+			      <property name="expand">False</property>
+			      <property name="fill">False</property>
+			    </packing>
+			  </child>
+			  
+			  <child>
+			    <widget class="GtkHBox" id="hbox_ac_disk">
+			      <property name="visible">True</property>
+			      <property name="homogeneous">True</property>
+			      <property name="spacing">12</property>
+
+			      <child>
+				<widget class="GtkLabel" id="label_ac_disk">
+				  <property name="visible">True</property>
+				  <property name="label" translatable="yes">Put dis_k to sleep when inactive for:</property>
+				  <property name="use_underline">True</property>
+				  <property name="use_markup">False</property>
+				  <property name="justify">GTK_JUSTIFY_LEFT</property>
+				  <property name="wrap">False</property>
+				  <property name="selectable">False</property>
+				  <property name="xalign">0</property>
+				  <property name="yalign">0.5</property>
+				  <property name="xpad">0</property>
+				  <property name="ypad">0</property>
+				  <property name="mnemonic_widget">hscale_ac_disk</property>
+				  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+				  <property name="width_chars">-1</property>
+				  <property name="single_line_mode">False</property>
+				  <property name="angle">0</property>
+				</widget>
+				<packing>
+				  <property name="padding">0</property>
+				  <property name="expand">False</property>
+				  <property name="fill">True</property>
+				</packing>
+			      </child>
+
+			      <child>
+				<widget class="GtkHScale" id="hscale_ac_disk">
+				  <property name="width_request">200</property>
+				  <property name="visible">True</property>
+				  <property name="can_focus">True</property>
+				  <property name="draw_value">True</property>
+				  <property name="value_pos">GTK_POS_BOTTOM</property>
+				  <property name="digits">0</property>
+				  <property name="update_policy">GTK_UPDATE_CONTINUOUS</property>
+				  <property name="inverted">False</property>
+				  <property name="adjustment">0 0 241 1 5 0</property>
+				</widget>
+				<packing>
+				  <property name="padding">0</property>
+				  <property name="expand">True</property>
+				  <property name="fill">True</property>
+				</packing>
+			      </child>
+			    </widget>
+			    <packing>
+			      <property name="padding">0</property>
+			      <property name="expand">False</property>
+			      <property name="fill">False</property>
+			    </packing>
+			  </child>
+
+			  <child>
+			    <widget class="GtkHBox" id="hbox_ac_hibernate">
+			      <property name="visible">True</property>
+			      <property name="homogeneous">True</property>
+			      <property name="spacing">12</property>
+
+			      <child>
+				<widget class="GtkLabel" id="label_ac_hibernate">
+				  <property name="visible">True</property>
+				  <property name="label" translatable="yes">_Hibernate computer when inactive for:</property>
+				  <property name="use_underline">True</property>
+				  <property name="use_markup">False</property>
+				  <property name="justify">GTK_JUSTIFY_LEFT</property>
+				  <property name="wrap">False</property>
+				  <property name="selectable">False</property>
+				  <property name="xalign">0</property>
+				  <property name="yalign">0.5</property>
+				  <property name="xpad">0</property>
+				  <property name="ypad">0</property>
+				  <property name="mnemonic_widget">hscale_ac_hibernate</property>
+				  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+				  <property name="width_chars">-1</property>
+				  <property name="single_line_mode">False</property>
+				  <property name="angle">0</property>
+				</widget>
+				<packing>
+				  <property name="padding">0</property>
+				  <property name="expand">False</property>
+				  <property name="fill">True</property>
+				</packing>
+			      </child>
+
+			      <child>
+				<widget class="GtkHScale" id="hscale_ac_hibernate">
+				  <property name="width_request">200</property>
+				  <property name="visible">True</property>
+				  <property name="can_focus">True</property>
+				  <property name="draw_value">True</property>
+				  <property name="value_pos">GTK_POS_BOTTOM</property>
+				  <property name="digits">0</property>
+				  <property name="update_policy">GTK_UPDATE_CONTINUOUS</property>
+				  <property name="inverted">False</property>
+				  <property name="adjustment">0 0 241 1 5 0</property>
 				</widget>
 				<packing>
 				  <property name="padding">0</property>
@@ -359,7 +494,7 @@
 				  <property name="digits">0</property>
 				  <property name="update_policy">GTK_UPDATE_CONTINUOUS</property>
 				  <property name="inverted">False</property>
-				  <property name="adjustment">23 1 61 1 5 0</property>
+				  <property name="adjustment">23 1 241 1 5 0</property>
 				</widget>
 				<packing>
 				  <property name="padding">0</property>
@@ -594,7 +729,143 @@
 				  <property name="digits">0</property>
 				  <property name="update_policy">GTK_UPDATE_CONTINUOUS</property>
 				  <property name="inverted">False</property>
-				  <property name="adjustment">1 1 61 1 5 0</property>
+				  <property name="adjustment">0 0 241 1 5 0</property>
+				</widget>
+				<packing>
+				  <property name="padding">0</property>
+				  <property name="expand">True</property>
+				  <property name="fill">True</property>
+				</packing>
+			      </child>
+			    </widget>
+			    <packing>
+			      <property name="padding">0</property>
+			      <property name="expand">False</property>
+			      <property name="fill">False</property>
+			    </packing>
+			  </child>
+
+
+			  <child>
+			    <widget class="GtkCheckButton" id="checkbutton_battery_suspend">
+			      <property name="visible">True</property>
+			      <property name="can_focus">True</property>
+			      <property name="label" translatable="yes">_Suspend computer when inactive for:</property>
+			      <property name="use_underline">True</property>
+			      <property name="relief">GTK_RELIEF_NORMAL</property>
+			      <property name="focus_on_click">True</property>
+			      <property name="active">False</property>
+			      <property name="inconsistent">False</property>
+			      <property name="draw_indicator">True</property>
+			    </widget>
+			    <packing>
+			      <property name="padding">0</property>
+			      <property name="expand">False</property>
+			      <property name="fill">False</property>
+			    </packing>
+			  </child>
+			  
+			  <child>
+			    <widget class="GtkHBox" id="hbox_battery_disk">
+			      <property name="visible">True</property>
+			      <property name="homogeneous">True</property>
+			      <property name="spacing">12</property>
+
+			      <child>
+				<widget class="GtkLabel" id="label_battery_disk">
+				  <property name="visible">True</property>
+				  <property name="label" translatable="yes">Put dis_k to sleep when inactive for:</property>
+				  <property name="use_underline">True</property>
+				  <property name="use_markup">False</property>
+				  <property name="justify">GTK_JUSTIFY_LEFT</property>
+				  <property name="wrap">False</property>
+				  <property name="selectable">False</property>
+				  <property name="xalign">0</property>
+				  <property name="yalign">0.5</property>
+				  <property name="xpad">0</property>
+				  <property name="ypad">0</property>
+				  <property name="mnemonic_widget">hscale_battery_disk</property>
+				  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+				  <property name="width_chars">-1</property>
+				  <property name="single_line_mode">False</property>
+				  <property name="angle">0</property>
+				</widget>
+				<packing>
+				  <property name="padding">0</property>
+				  <property name="expand">False</property>
+				  <property name="fill">True</property>
+				</packing>
+			      </child>
+
+			      <child>
+				<widget class="GtkHScale" id="hscale_battery_disk">
+				  <property name="width_request">200</property>
+				  <property name="visible">True</property>
+				  <property name="can_focus">True</property>
+				  <property name="draw_value">True</property>
+				  <property name="value_pos">GTK_POS_BOTTOM</property>
+				  <property name="digits">0</property>
+				  <property name="update_policy">GTK_UPDATE_CONTINUOUS</property>
+				  <property name="inverted">False</property>
+				  <property name="adjustment">0 0 241 1 5 0</property>
+				</widget>
+				<packing>
+				  <property name="padding">0</property>
+				  <property name="expand">True</property>
+				  <property name="fill">True</property>
+				</packing>
+			      </child>
+			    </widget>
+			    <packing>
+			      <property name="padding">0</property>
+			      <property name="expand">False</property>
+			      <property name="fill">False</property>
+			    </packing>
+			  </child>
+
+			  <child>
+			    <widget class="GtkHBox" id="hbox_battery_hibernate">
+			      <property name="visible">True</property>
+			      <property name="homogeneous">True</property>
+			      <property name="spacing">12</property>
+
+			      <child>
+				<widget class="GtkLabel" id="label_battery_hibernate">
+				  <property name="visible">True</property>
+				  <property name="label" translatable="yes">_Hibernate computer when inactive for:</property>
+				  <property name="use_underline">True</property>
+				  <property name="use_markup">False</property>
+				  <property name="justify">GTK_JUSTIFY_LEFT</property>
+				  <property name="wrap">False</property>
+				  <property name="selectable">False</property>
+				  <property name="xalign">0</property>
+				  <property name="yalign">0.5</property>
+				  <property name="xpad">0</property>
+				  <property name="ypad">0</property>
+				  <property name="mnemonic_widget">hscale_battery_hibernate</property>
+				  <property name="ellipsize">PANGO_ELLIPSIZE_NONE</property>
+				  <property name="width_chars">-1</property>
+				  <property name="single_line_mode">False</property>
+				  <property name="angle">0</property>
+				</widget>
+				<packing>
+				  <property name="padding">0</property>
+				  <property name="expand">False</property>
+				  <property name="fill">True</property>
+				</packing>
+			      </child>
+
+			      <child>
+				<widget class="GtkHScale" id="hscale_battery_hibernate">
+				  <property name="width_request">200</property>
+				  <property name="visible">True</property>
+				  <property name="can_focus">True</property>
+				  <property name="draw_value">True</property>
+				  <property name="value_pos">GTK_POS_BOTTOM</property>
+				  <property name="digits">0</property>
+				  <property name="update_policy">GTK_UPDATE_CONTINUOUS</property>
+				  <property name="inverted">False</property>
+				  <property name="adjustment">0 0 241 1 5 0</property>
 				</widget>
 				<packing>
 				  <property name="padding">0</property>
@@ -872,7 +1143,7 @@
 				  <property name="digits">0</property>
 				  <property name="update_policy">GTK_UPDATE_CONTINUOUS</property>
 				  <property name="inverted">False</property>
-				  <property name="adjustment">23 1 61 1 5 0</property>
+				  <property name="adjustment">23 1 241 1 5 0</property>
 				</widget>
 				<packing>
 				  <property name="padding">0</property>
@@ -1074,7 +1345,7 @@
 			      <child>
 				<widget class="GtkLabel" id="label_ups_computer">
 				  <property name="visible">True</property>
-				  <property name="label" translatable="yes">Put computer to _sleep when inactive for:</property>
+				  <property name="label" translatable="yes">Put power manageable devices to _sleep when inactive for:</property>
 				  <property name="use_underline">True</property>
 				  <property name="use_markup">False</property>
 				  <property name="justify">GTK_JUSTIFY_LEFT</property>
@@ -1124,6 +1395,24 @@
 			  </child>
 
 			  <child>
+			    <widget class="GtkCheckButton" id="checkbutton_ups_suspend">
+			      <property name="visible">True</property>
+			      <property name="can_focus">True</property>
+			      <property name="label" translatable="yes">_Suspend computer when inactive for:</property>
+			      <property name="use_underline">True</property>
+			      <property name="relief">GTK_RELIEF_NORMAL</property>
+			      <property name="focus_on_click">True</property>
+			      <property name="active">False</property>
+			      <property name="inconsistent">False</property>
+			      <property name="draw_indicator">True</property>
+			    </widget>
+			    <packing>
+			      <property name="padding">0</property>
+			      <property name="expand">False</property>
+			      <property name="fill">False</property>
+			    </packing>
+			  </child>
+			  <child>
 			    <widget class="GtkHBox" id="hbox18">
 			      <property name="visible">True</property>
 			      <property name="homogeneous">True</property>
@@ -1352,7 +1641,7 @@
 				  <property name="digits">0</property>
 				  <property name="update_policy">GTK_UPDATE_CONTINUOUS</property>
 				  <property name="inverted">False</property>
-				  <property name="adjustment">23 1 61 1 5 0</property>
+				  <property name="adjustment">23 1 241 1 5 0</property>
 				</widget>
 				<packing>
 				  <property name="padding">0</property>
--- src/Makefile.am.org	2007-12-06 18:35:27.087516000 +0800
+++ src/Makefile.am	2007-12-06 18:19:22.967928000 +0800
@@ -105,6 +105,12 @@
 	gpm-common.c					\
 	gpm-screensaver.h				\
 	gpm-screensaver.c				\
+        gpm-ac-adapter.c                                \
+        gpm-ac-adapter.h                                \
+        gpm-solaris-conf.c                              \
+        gpm-solaris-conf.h                              \
+        gpm-system-interrogator.c                       \
+        gpm-system-interrogator.h                       \
 	$(NULL)
 
 gnome_power_preferences_LDADD =				\
@@ -117,6 +123,9 @@
 	$(LOCAL_LIBDBUS_LIBS)				\
 	$(NULL)
 
+gnome_power_preferences_LDADD +=			\
+	-ldevinfo
+
 if HAVE_GTKUNIQUE
 gnome_power_preferences_LDADD +=			\
 	$(GTKUNIQUE_LIBS)
@@ -205,6 +214,10 @@
 	gpm-graph-widget.c				\
 	gpm-feedback-widget.h				\
 	gpm-feedback-widget.c				\
+        gpm-solaris-conf.c                              \
+        gpm-solaris-conf.h                              \
+        gpm-system-interrogator.c                       \
+        gpm-system-interrogator.h                       \
 	$(NULL)
 
 gnome_power_manager_LDADD =				\
@@ -218,6 +231,11 @@
 	$(LOCAL_LIBDBUS_LIBS)				\
 	$(NULL)
 
+#if SOLARIS
+gnome_power_manager_LDADD +=                        	\
+        -ldevinfo
+#endif
+
 if HAVE_LIBNOTIFY
 gnome_power_manager_LDADD +=				\
 	$(LIBNOTIFY_LIBS)				\
--- src/gpm-manager.c.org	2007-12-06 18:35:27.054382000 +0800
+++ src/gpm-manager.c	2007-12-06 18:15:21.394880000 +0800
@@ -46,6 +46,9 @@
 #include "gpm-ac-adapter.h"
 #include "gpm-button.h"
 #include "gpm-conf.h"
+#ifdef SOLARIS
+#include "gpm-solaris-conf.h"
+#endif /* SOLARIS */
 #include "gpm-control.h"
 #include "gpm-common.h"
 #include "gpm-cpufreq.h"
@@ -96,6 +99,7 @@
 	GpmEngine		*engine;
 	HalGPower		*hal_power;
 	gboolean		 low_power;
+	GpmSolarisConf		*solaris_conf;
 
 	/* interactive services */
 	GpmBacklight		*backlight;
@@ -1695,6 +1699,9 @@
 	g_signal_connect (manager->priv->conf, "value-changed",
 			  G_CALLBACK (conf_key_changed_cb), manager);
 
+	/* Just let solaris conf object exist */ 
+	manager->priv->solaris_conf = gpm_solaris_conf_new ();
+
 	/* check to see if the user has installed the schema properly */
 	ret = gpm_conf_get_uint (manager->priv->conf, GPM_CONF_SCHEMA_VERSION, &version);
 	if (ret == FALSE || version != GPM_CONF_SCHEMA_ID) {
@@ -1844,6 +1851,7 @@
 
 	/* compulsory gobjects */
 	g_object_unref (manager->priv->conf);
+	g_object_unref (manager->priv->solaris_conf);
 	g_object_unref (manager->priv->hal_power);
 	g_object_unref (manager->priv->sound);
 	g_object_unref (manager->priv->dpms);
--- src/gpm-prefs-core.c.org	2007-12-06 18:35:27.087239000 +0800
+++ src/gpm-prefs-core.c	2007-12-06 18:50:24.526478000 +0800
@@ -44,6 +44,7 @@
 #include "gpm-stock-icons.h"
 #include "gpm-screensaver.h"
 #include "gpm-prefs-server.h"
+#include "gpm-solaris-conf.h"
 
 static void     gpm_prefs_class_init (GpmPrefsClass *klass);
 static void     gpm_prefs_init       (GpmPrefs      *prefs);
@@ -66,6 +67,11 @@
 	GpmScreensaver		*screensaver;
 	HalGCpufreq		*hal_cpufreq;
 	HalGCpufreqType		 cpufreq_types;
+	GpmSolarisConf		*solaris_conf;
+	gboolean		has_pm_perm;	/* Permission of changing pm configuration */
+	gboolean		has_asd_perm;   /* Permission of changing autoshutdwon configuration */
+	gboolean		has_autoS3;
+	gboolean		has_asd;
 };
 
 enum {
@@ -93,8 +99,9 @@
 #define CPUFREQ_POWERSAVE_TEXT		_("Maximum power saving")
 #define CPUFREQ_PERFORMANCE_TEXT	_("Always maximum speed")
 
-/* If sleep time in a slider is set to 61 it is considered as never */
-const int NEVER_TIME_ON_SLIDER = 61;
+
+/* If sleep time in a slider is set to 241 it is considered as always-on */
+const int NEVER_TIME_ON_SLIDER = 241;
 
 /**
  * gpm_prefs_class_init:
@@ -284,6 +291,8 @@
 {
 	gchar *str;
 	if ((gint) value == NEVER_TIME_ON_SLIDER) {
+		str = g_strdup (_("Always-on"));
+	} else if ((gint) value == 0 ) {
 		str = g_strdup (_("Never"));
 	} else {
 		str = gpm_get_timestring (value * 60);
@@ -305,10 +314,15 @@
 	char *gpm_pref_key;
 
 	value = (int) gtk_range_get_value (range);
+	gpm_pref_key = (char *) g_object_get_data (G_OBJECT (range), "conf_key");	
 
 	if (value == NEVER_TIME_ON_SLIDER) {
-		/* power manager interprets 0 as Never */
-		value = 0;
+		/* display interprets 0 as Never */
+		if (strcmp (gpm_pref_key, GPM_CONF_TIMEOUT_SLEEP_DISPLAY_AC) 
+		    || strcmp (gpm_pref_key, GPM_CONF_TIMEOUT_SLEEP_DISPLAY_BATT))
+			value = 0;
+		else
+			value = INT_MAX;
 	} else {
 		/* We take away the g-s idle time as the slider represents
 		 * global time but we only do our timeout from when g-s
@@ -320,7 +334,6 @@
 		value *= 60;
 	}
 
-	gpm_pref_key = (char *) g_object_get_data (G_OBJECT (range), "conf_key");
 	gpm_debug ("Changing %s to %i", gpm_pref_key, value);
 	gpm_conf_set_int (prefs->priv->conf, gpm_pref_key, value);
 }
@@ -350,7 +363,7 @@
 
 	gtk_widget_set_sensitive (widget, is_writable);
 
-	if (value == 0) {
+	if (value > NEVER_TIME_ON_SLIDER * 60) {
 		value = NEVER_TIME_ON_SLIDER;
 	} else {
 		/* policy is in seconds, slider is in minutes */
@@ -656,9 +669,7 @@
 		     GpmPrefs	    *prefs)
 {
 	/* update the start and stop points on the hscales */
-	set_idle_hscale_stops (prefs, "hscale_battery_computer", delay);
 	set_idle_hscale_stops (prefs, "hscale_battery_display", delay);
-	set_idle_hscale_stops (prefs, "hscale_ac_computer", delay);
 	set_idle_hscale_stops (prefs, "hscale_ac_display", delay);
 }
 
@@ -905,6 +916,42 @@
 	}
 }
 
+/* 
+ * Setup Solaris-specific entries in AC tab, including autopm,
+ * disk-threshold, autoS3, autoshutdown.
+ */
+static void
+prefs_setup_ac_solaris_entry (GpmPrefs *prefs)
+{
+	GtkWidget *widget;
+	
+	gpm_prefs_setup_sleep_slider (prefs, "hscale_ac_computer",
+				      GPM_CONF_SOLARIS_TIMEOUT_SLEEP_COMPUTER_AC);
+	gpm_prefs_setup_sleep_slider (prefs, "hscale_ac_disk",
+				      GPM_CONF_SOLARIS_TIMEOUT_SLEEP_DISK_AC);
+	gpm_prefs_setup_checkbox (prefs, "checkbutton_ac_suspend",
+				  GPM_CONF_SOLARIS_SUSPEND_AC);
+	gpm_prefs_setup_sleep_slider (prefs, "hscale_ac_hibernate",
+				      GPM_CONF_SOLARIS_TIMEOUT_HIBERNATE_AC);
+	
+	if (prefs->priv->has_pm_perm == FALSE) {
+		widget = glade_xml_get_widget (prefs->priv->glade_xml, "hbox_ac_computer");
+		gtk_widget_hide_all (widget);
+		widget = glade_xml_get_widget (prefs->priv->glade_xml, "hbox_ac_disk");
+		gtk_widget_hide_all (widget);
+	}
+	if (prefs->priv->has_autoS3 == FALSE 
+	    || prefs->priv->has_pm_perm == FALSE) {
+		widget = glade_xml_get_widget (prefs->priv->glade_xml, "checkbutton_ac_suspend");
+		gtk_widget_hide_all (widget);
+	}
+	if (prefs->priv->has_asd == FALSE
+	    || prefs->priv->has_asd_perm == FALSE) {
+		widget = glade_xml_get_widget (prefs->priv->glade_xml, "hbox_ac_hibernate");
+		gtk_widget_hide_all (widget);
+	}
+}
+	
 static void
 prefs_setup_ac (GpmPrefs *prefs)
 {
@@ -923,8 +970,7 @@
 				      button_lid_actions);
 	gpm_prefs_setup_processor_combo (prefs, "combobox_ac_cpu",
 					 GPM_CONF_CPUFREQ_POLICY_AC, prefs->priv->cpufreq_types);
-	gpm_prefs_setup_sleep_slider (prefs, "hscale_ac_computer",
-				      GPM_CONF_TIMEOUT_SLEEP_COMPUTER_AC);
+	prefs_setup_ac_solaris_entry (prefs);
 	gpm_prefs_setup_sleep_slider (prefs, "hscale_ac_display",
 				      GPM_CONF_TIMEOUT_SLEEP_DISPLAY_AC);
 	gpm_prefs_setup_brightness_slider (prefs, "hscale_ac_brightness",
@@ -934,7 +980,6 @@
 				  GPM_CONF_BACKLIGHT_IDLE_DIM_AC);
 
 	delay = gpm_screensaver_get_delay (prefs->priv->screensaver);
-	set_idle_hscale_stops (prefs, "hscale_ac_computer", delay);
 	set_idle_hscale_stops (prefs, "hscale_ac_display", delay);
 
 	if (prefs->priv->has_button_lid == FALSE) {
@@ -959,6 +1004,42 @@
 	}
 }
 
+/* 
+ * Setup Solaris-specific entries in battery tab, including autopm,
+ * disk-threshold, autoS3, autoshutdown.
+ */
+static void
+prefs_setup_battery_solaris_entry (GpmPrefs *prefs)
+{
+	GtkWidget *widget;
+	
+	gpm_prefs_setup_sleep_slider (prefs, "hscale_battery_computer",
+				      GPM_CONF_SOLARIS_TIMEOUT_SLEEP_COMPUTER_BATT);
+	gpm_prefs_setup_sleep_slider (prefs, "hscale_battery_disk",
+				      GPM_CONF_SOLARIS_TIMEOUT_SLEEP_DISK_BATT);
+	gpm_prefs_setup_checkbox (prefs, "checkbutton_battery_suspend",
+				  GPM_CONF_SOLARIS_SUSPEND_BATT);
+	gpm_prefs_setup_sleep_slider (prefs, "hscale_battery_hibernate",
+				      GPM_CONF_SOLARIS_TIMEOUT_HIBERNATE_BATT);
+	
+	if (prefs->priv->has_pm_perm == FALSE) {
+		widget = glade_xml_get_widget (prefs->priv->glade_xml, "hbox_battery_computer");
+		gtk_widget_hide_all (widget);
+		widget = glade_xml_get_widget (prefs->priv->glade_xml, "hbox_battery_disk");
+		gtk_widget_hide_all (widget);
+	}
+	if (prefs->priv->has_autoS3 == FALSE 
+	    || prefs->priv->has_pm_perm == FALSE) {
+		widget = glade_xml_get_widget (prefs->priv->glade_xml, "checkbutton_battery_suspend");
+		gtk_widget_hide_all (widget);
+	}
+	if (prefs->priv->has_asd == FALSE
+	    || prefs->priv->has_asd_perm == FALSE) {
+		widget = glade_xml_get_widget (prefs->priv->glade_xml, "hbox_battery_hibernate");
+		gtk_widget_hide_all (widget);
+	}
+}
+
 static void
 prefs_setup_battery (GpmPrefs *prefs)
 {
@@ -997,8 +1078,7 @@
 				      battery_critical_actions);
 	gpm_prefs_setup_processor_combo (prefs, "combobox_battery_cpu",
 					 GPM_CONF_CPUFREQ_POLICY_BATT, prefs->priv->cpufreq_types);
-	gpm_prefs_setup_sleep_slider (prefs, "hscale_battery_computer",
-				      GPM_CONF_TIMEOUT_SLEEP_COMPUTER_BATT);
+	prefs_setup_battery_solaris_entry (prefs);
 	gpm_prefs_setup_sleep_slider (prefs, "hscale_battery_display",
 				      GPM_CONF_TIMEOUT_SLEEP_DISPLAY_BATT);
 	gpm_prefs_setup_brightness_slider (prefs, "hscale_battery_brightness",
@@ -1013,7 +1093,6 @@
 	}
 
 	delay = gpm_screensaver_get_delay (prefs->priv->screensaver);
-	set_idle_hscale_stops (prefs, "hscale_battery_computer", delay);
 	set_idle_hscale_stops (prefs, "hscale_battery_display", delay);
 
 	if (prefs->priv->has_button_lid == FALSE) {
@@ -1067,8 +1146,6 @@
 				      ups_low_actions);
 	gpm_prefs_setup_sleep_slider (prefs, "hscale_ups_computer",
 				      GPM_CONF_TIMEOUT_SLEEP_COMPUTER_BATT);
-	delay = gpm_screensaver_get_delay (prefs->priv->screensaver);
-	set_idle_hscale_stops (prefs, "hscale_ups_computer", delay);
 }
 
 static void
@@ -1173,6 +1250,16 @@
 	g_signal_connect (widget, "clicked",
 			  G_CALLBACK (gpm_prefs_help_cb), prefs);
 
+	prefs->priv->solaris_conf = gpm_solaris_conf_new ();
+	if (prefs->priv->solaris_conf == NULL) {
+		g_error ("Cannot initialize Solaris power configuration info.");
+	} else {
+		prefs->priv->has_pm_perm = gpm_solaris_conf_get_pm_perm (prefs->priv->solaris_conf);
+		prefs->priv->has_asd_perm = gpm_solaris_conf_get_autoshutdown_perm (prefs->priv->solaris_conf);
+		prefs->priv->has_autoS3 = gpm_solaris_conf_get_autoS3_capable (prefs->priv->solaris_conf);
+		prefs->priv->has_asd = gpm_solaris_conf_get_autoshutdown_capable (prefs->priv->solaris_conf);
+	}
+
 	prefs_setup_ac (prefs);
 	prefs_setup_battery (prefs);
 	prefs_setup_ups (prefs);
@@ -1197,6 +1284,7 @@
 	prefs->priv = GPM_PREFS_GET_PRIVATE (prefs);
 
 	g_object_unref (prefs->priv->conf);
+	g_object_unref (prefs->priv->solaris_conf);
 	if (prefs->priv->screensaver) {
 		g_object_unref (prefs->priv->screensaver);
 	}
--- src/gpm-conf.h.org	2007-12-06 18:35:27.054014000 +0800
+++ src/gpm-conf.h	2007-12-06 00:30:31.952141000 +0800
@@ -120,6 +120,16 @@
 #define GPM_CONF_NOTIFY_ESTIMATED_DATA		GPM_CONF_DIR "/notify/estimated_data"
 #define GPM_CONF_NOTIFY_INHIBIT_LID		GPM_CONF_DIR "/notify/inhibit_lid"
 
+/* Solaris-specific keys */
+#define GPM_CONF_SOLARIS_TIMEOUT_SLEEP_COMPUTER_AC 	GPM_CONF_DIR "/solaris/sleep_computer_ac"
+#define GPM_CONF_SOLARIS_TIMEOUT_SLEEP_DISK_AC 		GPM_CONF_DIR "/solaris/sleep_disk_ac"
+#define GPM_CONF_SOLARIS_SUSPEND_AC 			GPM_CONF_DIR "/solaris/sleep_suspend_ac"
+#define GPM_CONF_SOLARIS_TIMEOUT_HIBERNATE_AC 		GPM_CONF_DIR "/solaris/sleep_hibernate_ac"
+#define GPM_CONF_SOLARIS_TIMEOUT_SLEEP_COMPUTER_BATT 	GPM_CONF_DIR "/solaris/sleep_computer_battery"
+#define GPM_CONF_SOLARIS_TIMEOUT_SLEEP_DISK_BATT 	GPM_CONF_DIR "/solaris/sleep_disk_battery"
+#define GPM_CONF_SOLARIS_SUSPEND_BATT 			GPM_CONF_DIR "/solaris/sleep_suspend_battery"
+#define GPM_CONF_SOLARIS_TIMEOUT_HIBERNATE_BATT 	GPM_CONF_DIR "/solaris/sleep_hibernate_battery"
+
 /* statistics */
 #define GPM_CONF_STATS_SHOW_AXIS_LABELS		GPM_CONF_DIR "/statistics/show_axis_labels"
 #define GPM_CONF_STATS_SHOW_EVENTS		GPM_CONF_DIR "/statistics/show_events"
--- src/gpm-system-interrogator.c.org	2007-12-06 18:36:14.607784000 +0800
+++ src/gpm-system-interrogator.c	2007-12-06 18:26:22.179007000 +0800
@@ -0,0 +1,369 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2007 Richard Hughes <simon.zheng@sun.com>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+#include <glib.h>
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/cpr.h>
+#include <sys/uadmin.h>
+#include <libdevinfo.h>
+#include <sys/pm.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <stropts.h>
+#include <strings.h>
+#include <pwd.h>
+#include <utmpx.h>
+#include <deflt.h>
+
+#include "gpm-system-interrogator.h"
+
+/*
+ *  CPR. Get setting from file CPR_CONFIG which
+ *  stores the current setting using.
+ */
+#define	to_GBOOL(val) (((val) == 0) ? FALSE : TRUE)
+
+cpr_info_t *
+gpm_system_interrogater_get_cpr_info (void)
+{
+	int			fd;
+	struct cprconfig 	info;
+	cpr_info_t *ret = NULL;
+	
+	if ((fd = open (CPR_CONFIG, O_RDONLY)) < 0) {
+		g_warning ("Could not open /etc/.cpr_config.\n");
+		return (NULL);
+	}
+
+	if (read(fd, &info, sizeof (info)) != sizeof (info)) {
+		g_warning ("Could not read /etc/.cpr_config.");
+		close(fd);
+		return (NULL);
+	}
+	close(fd);
+
+	ret = g_new0 (cpr_info_t, 1);
+	
+	ret->asd_capable = to_GBOOL(info.is_cpr_capable);
+	ret->asd_default = to_GBOOL(info.is_cpr_default);
+	    		
+	ret->wakeup_capable = to_GBOOL(info.is_autowakeup_capable);
+	ret->autopm_default = to_GBOOL(info.is_autopm_default);
+
+	/* 
+	 * XXXXXX
+	 * Fix ME, uadmin only allow to be called by root user.
+	 * We need new interface to check S3 capability. Now make
+	 * it always TRUE.
+	 */
+	//if (uadmin(A_FREEZE, AD_CHECK_SUSPEND_TO_RAM, 0) == 0)
+	//	ret->autoS3_capable = TRUE;
+	//else
+	//	ret->autoS3_capable = FALSE;
+	ret->autoS3_capable = TRUE;
+	ret->autoS3_default = TRUE;
+
+	return (ret);
+}
+
+
+/**
+ * perm_t
+ */
+
+static struct utmpx utmp;
+
+#define	DEFAULTFILE		"/etc/default/power"
+#define	CONSOLE			"/dev/console"
+#define	MAX_USER_LEN		(sizeof (utmp.ut_name))
+
+static int
+has_cnowner_perms(uid_t user_uid)
+{
+	struct stat sbuf;
+
+	if (stat (CONSOLE, &sbuf)) {
+		return (0);
+	} else {
+		return (user_uid == sbuf.st_uid);
+	}
+}
+
+#define	BEGIN_TOKEN	'<'
+#define	END_TOKEN	'>'
+
+static int
+has_userlist_perms (char *user,
+			   char *list)
+{
+	char	*tokenp;
+
+	if (*list == BEGIN_TOKEN) {
+		list = list + 1;
+		if ((tokenp = strrchr(list, END_TOKEN)) != NULL) {
+			*tokenp = '\0';
+			while ((tokenp = strtok(list, ", ")) != NULL) {
+				list = NULL;
+				if (strcmp(user, tokenp) == 0) {
+					return (1);
+				}
+			}
+		}
+	}
+	return (0);
+}
+
+perm_t *
+gpm_system_interrogator_get_perm (void)
+{
+	perm_t *ret;
+	gboolean	cprchangeperm = FALSE;
+	gboolean	pmchangeperm = FALSE;
+
+	char		*pstr;
+	char		user[MAX_USER_LEN];
+	int		user_uid = getuid();
+
+	strcpy(user, (getpwuid (user_uid))->pw_name);
+
+	if (user_uid == 0) {
+		cprchangeperm = TRUE;
+		pmchangeperm = TRUE;
+	} else {
+		/*
+		 * possible CPRCHANGEPERM  and PMCHANGEPERM entries are:
+		 *   all		   (all users + root)
+		 *   -			   (none + root)
+		 *   <user1<delimeter>...> (listed users + root)
+		 *   console-owner	   (console onwer + root. default)
+		 * Any error in reading/parsing the file allows only root
+		 * to use the program
+		 */
+		if (defopen(DEFAULTFILE) == 0) {
+			if ((pstr = defread("CPRCHANGEPERM=")) != NULL) {
+				if (strcmp("all", pstr) == 0) {
+					cprchangeperm = TRUE;
+				} else if (strcmp("console-owner", pstr) == 0) {
+					if (has_cnowner_perms(user_uid)) {
+						cprchangeperm = TRUE;
+					}
+				} else if (has_userlist_perms(user, pstr)) {
+					cprchangeperm = TRUE;
+				}
+			}
+
+			if ((pstr = defread("PMCHANGEPERM=")) != NULL) {
+				if (strcmp("all", pstr) == 0) {
+					pmchangeperm = TRUE;
+				} else if (strcmp("console-owner", pstr) == 0) {
+					if (has_cnowner_perms(user_uid)) {
+						pmchangeperm = TRUE;
+					}
+				} else if (has_userlist_perms(user, pstr)) {
+					pmchangeperm = TRUE;
+				}
+			}
+			(void) defopen((char *)NULL);
+		} else {
+			g_warning ("Unable to check power management perm_t.\n");
+			return (NULL);
+		}
+	}
+
+	ret = g_new0 (perm_t, 1);
+	ret->asd_change_perm = cprchangeperm,
+	ret->pm_change_perm = pmchangeperm;
+
+	return (ret);
+}
+
+/* 
+ * Get the list of power manageable devices.
+ * Actually only care about harddisk so far.
+ */
+static int	save_name(di_node_t, void *);
+static int	build_device_list(void);
+static void	free_device_list(void);
+static int	diskcb(di_node_t, di_minor_t, void *);
+
+typedef struct devlist {
+	char pname[MAXPATHLEN];
+	struct devlist *next;
+} devlist_t;
+
+static devlist_t	*devlisthead_p = NULL;
+static int		dev_count = 0;
+
+/*
+ * Get a array of device names, NULL identifies end.
+ */
+int
+gpm_system_interrogator_get_all_device_names (char ***device_list)
+{
+	devlist_t	*listp;
+	int		i;
+	char	 	**list;
+	int		ret;
+
+	if (build_device_list() < 0) {
+		/*
+		 * Something went wrong, we could not traverse the device
+		 * tree, throw exception and return since there is not any
+		 * more we can do.
+		 */
+		g_warning ("Could not build device list.\n");
+		return (NULL);
+	}
+
+	if (dev_count == 0) {
+		*device_list = NULL;
+		return 0;
+	} else
+		ret = dev_count;
+
+	list = g_new0 (char *, dev_count);
+	for (listp = devlisthead_p, i = 0; 
+	     i < dev_count; 
+	     listp = listp->next, i++) {
+		list[i] = g_strdup (listp->pname);
+	}
+
+	free_device_list();
+	*device_list = list;
+	return ret;
+}
+
+/*
+ * Traverces the devicetree starting at "/".
+ * Returns < 0 on error and other values on success.
+ */
+static int
+build_device_list(void)
+{
+	di_node_t	root_node;
+	int 		pmfd;
+
+	if ((root_node = di_init("/", (DINFOSUBTREE | DINFOMINOR))) == NULL) {
+		return (-1);
+	}
+
+	if ((pmfd = open("/dev/pm", O_RDONLY)) < 0) {
+		g_warning ("Could not open power management device (/dev/pm).\n");
+		return (-1);
+	}
+	if (di_walk_node(root_node, DI_WALK_CLDFIRST, pmfd, save_name) < 0) {
+		g_warning ("Could not di_walk_node.\n");
+		return (-1);
+	}
+	close(pmfd);
+	di_fini(root_node);
+	return (0);
+}
+
+
+/*
+ * The callback function used by di_walk_node. It scans if the device
+ * has autopm, in which case it adds it to the device list.
+ */
+static int
+save_name(di_node_t node, void *arg)
+{
+	pm_req_t	pmstr;
+	char		*path;
+	devlist_t	*newlistp;
+
+	if (path = di_devfs_path(node)) {
+		/*
+		 * Here has to be done some screening, preferably by
+		 * asking the device if it can do autopm.
+		 */
+		pmstr.physpath = path;
+		/*
+		 * Has to have at least 1 component, ask about the
+		 * first one.
+		 */
+		pmstr.component = 0;
+
+		/*
+		 * We deliberately do not check for failure of this ioctl.
+		 * That simply means the device has no power management
+		 * information.
+		 */
+		if (ioctl((int)arg, PM_GET_DEVICE_TYPE, &pmstr) == PM_AUTOPM) {
+			char nodetype[MAXNAMELEN];
+
+			if (di_walk_minor(node, NULL, 0, nodetype, diskcb) >= 0) {
+				/* Only keep harddisk device */
+				if (strcmp (nodetype, "harddisk") == 0) {
+					newlistp = g_new0(devlist_t, 1);
+					(void) strcpy(newlistp->pname, path);
+					newlistp->next = devlisthead_p;
+					devlisthead_p = newlistp;
+					dev_count++;
+				}
+			}
+		}
+		di_devfs_path_free(path);
+	}
+	/* keep traversing the tree */
+	return (DI_WALK_CONTINUE);
+}
+
+
+static void
+free_device_list(void)
+{
+	devlist_t	*listp;
+	devlist_t	*tmplistp;
+
+	listp = devlisthead_p;
+
+	while (listp != NULL) {
+		tmplistp = listp;
+		listp = listp->next;
+		g_free(tmplistp);
+	}
+
+	devlisthead_p = NULL;
+	dev_count = 0;
+}
+
+
+static int
+diskcb(di_node_t node, di_minor_t minor, void *nodetype)
+{
+	char	*np = NULL;
+
+	if ((np = di_minor_nodetype(minor)) != NULL) {
+
+		if ((strcmp(np, DDI_NT_BLOCK) == 0) ||
+		    (strcmp(np, DDI_NT_BLOCK_CHAN) == 0) ||
+		    (strcmp(np, DDI_NT_BLOCK_WWN) == 0)) {
+			strcpy((char *)nodetype, "harddisk");
+		} else {
+			strcpy((char *)nodetype, "NA");  /* Not Applied */
+		}
+	} else {
+		strcpy((char *)nodetype, "NA");  /* Not Applied */
+	}
+	return (DI_WALK_TERMINATE);
+}
--- src/gpm-system-interrogator.h.org	2007-12-06 18:36:32.956248000 +0800
+++ src/gpm-system-interrogator.h	2007-12-05 15:18:05.535659000 +0800
@@ -0,0 +1,61 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2007 Richard Hughes <simon.zheng@sun.com>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+#ifndef GPM_SYSTEM_INTERROGATOR_H
+#define GPM_SYSTEM_INTERROGATOR_H
+
+typedef struct __cpr_info_t {
+	gboolean asd_capable;
+	gboolean asd_default;
+	gboolean wakeup_capable;
+	gboolean autopm_default;
+	gboolean autoS3_capable;
+	gboolean autoS3_default;
+}cpr_info_t;
+
+
+typedef struct __perm_t{
+	gboolean asd_change_perm;
+	gboolean pm_change_perm;
+}perm_t;
+
+typedef struct __dpms_info_t{
+	gboolean dpms_capable;
+	gboolean dpms_enabled;
+		
+	gint standby;  // timeout for standby mode
+	gint suspend;  // timeout for suspend mode 
+	gint off;   // timeout for off mode
+	
+	gboolean fbpm_capable;
+	gboolean fbpm_on;
+}dpms_info_t;
+
+
+cpr_info_t *
+gpm_system_interrogater_get_cpr_info (void);
+
+perm_t *
+gpm_system_interrogator_get_perm(void);
+
+int
+gpm_system_interrogator_get_all_device_names (char ***);
+
+#endif /*GPM_SYSTEM_INTERROGATOR_H*/
--- src/gpm-solaris-conf.c.org	1970-01-01 08:00:00.000000000 +0800
+++ src/gpm-solaris-conf.c	2007-12-06 13:22:23.399590000 +0800
@@ -0,0 +1,1009 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2007 Richard Hughes <simon.zheng@sun.com>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+#include "config.h"
+
+#include <glib.h>
+#include <glib/gprintf.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif /* HAVE_UNISTD_H */
+#include <sys/wait.h>
+#include <string.h>
+#include <errno.h>
+
+#include "gpm-conf.h"
+#include "gpm-ac-adapter.h"
+#include "gpm-system-interrogator.h"
+#include "gpm-solaris-conf.h"
+
+#define GPM_SOLARIS_CONF_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GPM_TYPE_SOLARIS_CONF, GpmSolarisConfPrivate))
+
+struct GpmSolarisConfPrivate
+{
+ 	GpmConf			*conf;
+	GpmAcAdapter		*ac_adapter;
+	
+	/* autoshutdown configuration field */
+ 	gboolean asd_capable;
+	gboolean asd_default;  /* FALSE - disable, TRUE - enable */
+	gboolean asd_enabled;
+	gboolean wakeup_capable;
+	gboolean wakeup_enabled;	
+ 	guint	as_idle;	/* idle time in min */
+ 	guint	as_sh;		/* Start_time hour */
+ 	guint	as_sm;		/* Start_time minutes */
+ 	guint	as_fh;		/* Finish_time hour */
+ 	guint	as_fm;		/* Finish_time minute */
+
+ 	/* autopm behavior field */
+ 	gboolean autopm_default; /* FALSE - disable, TRUE - enable */
+ 	gboolean autopm_enabled;		
+ 	guint 	sys_threshold;
+
+	/* device-threshoulds field */
+	gchar 	**disk_list;  /* keep a list of power manageable hardisks */
+	int	disk_num;    /* the number of harddisk devices */
+	guint	disk_threshold;
+	
+	/* autoS3 behavior field */
+	gboolean autoS3_capable;
+ 	gboolean autoS3_default; 
+	gboolean autoS3_enabled;
+ 	
+	/* Other lines this program unables to identify*/
+ 	gchar *unidentified;     
+
+	/* Permissions of cpr and pm */
+ 	gboolean asd_change_perm;
+	gboolean pm_change_perm;
+};
+
+
+G_DEFINE_TYPE (GpmSolarisConf, gpm_solaris_conf, G_TYPE_OBJECT)
+static gpointer gpm_solaris_conf_object = NULL;
+
+
+/** 
+ * A set of values identify to caller the type 
+ * of command parsed from the configure file.
+ */
+enum {
+	AUTOPM,
+	AUTOS3,
+	SYSTEM_THRESHOLD,
+	DEVICE_THRESHOLDS,
+	DISK_THRESHOLD,
+	AUTOSHUTDOWN,
+	STATEFILE,
+	COMMENT,
+	UNKNOWN
+};     
+
+/*
+ * Convert a numeric string (with a possible trailing scaling byte)
+ * into an integer.  Returns a converted value and *nerrp unchanged,
+ * or 0 with *nerrp set to 1 for a conversion error.
+ */
+static int
+get_scaled_value (const char *str, int *nerrp)
+{
+	long svalue = 0, factor = 1;
+	char *sp;
+
+	svalue = strtol(str, &sp, 0);
+	if (svalue == 0 || *str == '-')
+		*nerrp = 1;
+	else if (sp && *sp != '\0') {
+		if (*sp == 'h')
+			factor = 3600;
+		else if (*sp == 'm')
+			factor = 60;
+		else if (*sp != 's')
+			*nerrp = 1;
+	}
+	
+	/* any bytes following sp are ignored */
+	if (*nerrp == 0) {
+		svalue *= factor;
+		if (svalue < INT_MIN || svalue > INT_MAX)
+			*nerrp = 1;
+	}
+	if (*nerrp)
+		g_warning ("Failed to get scale value for %s\n", str);
+	g_printf ("got scaled value %d\n", (int)svalue);
+	return ((int)svalue);
+}
+
+
+/**
+ * Parse the threshold portion of a command.
+ * If failure, return -1.
+ */
+static int
+parse_threshold (char *thresh)
+{
+	int value, nerr = 0;
+	
+	if (strcmp(thresh, "always-on") == 0)
+		value = INT_MAX;
+	else if ((value = get_scaled_value (thresh, &nerr)) < 0 || nerr) {
+		g_warning ("Threshold must be a positive value!\n");
+		return -1;
+	}
+	
+	return value;
+}
+  
+static int
+parse_systhreshold (int argc, char **line_args, struct GpmSolarisConfPrivate *pc)
+{
+	int value;
+
+	if (argc != 2) {
+		g_warning ("Invaild syntax for systhreshold!\n");
+		return -1;
+	}
+
+	value = parse_threshold (line_args[1]);	
+	pc->sys_threshold = (value == -1) ? 0 : value;
+	return SYSTEM_THRESHOLD;
+}
+
+/*
+ * Check for a real device and try to resolve to a full path.
+ * The orig/resolved path may be modified into a prom pathname,
+ * and an allocated copy of the result is stored at *destp;
+ * the caller will need to free that space.  Returns 1 for any
+ * error, otherwise 0.
+ */
+static int
+devpath (char **destp, char *src)
+{
+	struct stat stbuf;
+	char buf[PATH_MAX];
+	char *cp, *dstr;
+	int devok, dcs = 0;
+	size_t len;
+
+	/*
+	 * When there's a real device, try to resolve the path
+	 * and trim the leading "/devices" component.
+	 */
+	if ((devok = (stat(src, &stbuf) == 0 && stbuf.st_rdev)) != 0) {
+		if (realpath(src, buf) == NULL) {
+			g_printf ("realpath cannot resolve \"%s\"\n", src);
+			return (1);
+		}
+		src = buf;
+		dstr = "/devices";
+		len = strlen(dstr);
+		dcs = (strncmp(src, dstr, len) == 0);
+		if (dcs)
+			src += len;
+	} else
+		g_printf ("can not stat \"%s\", may be a devpath\n,", src);
+
+	/*
+	 * When the path has ":anything", display an error for
+	 * a non-device or truncate a resolved+modifed path.
+	 */
+	if (cp = strchr(src, ':')) {
+		if (devok == 0) {
+			g_warning ("physical path may not contain "
+			    "a minor string (%s)\n", src);
+			return (1);
+		} else if (dcs)
+			*cp = '\0';
+	}
+
+	if ((*destp = g_strdup(src)) == NULL) {
+		g_warning ("failed to call g_strdup.\n");
+	}
+	return (*destp == NULL);
+}
+
+
+/*
+ * Functionality: Only parse "disk" type of device-thresholds and 
+ * restrieve its threshold.
+ * 
+ * Return value: Return -1 when syntax is invalid; Return UNKNOWN
+ * when device isn't a harddisk; Otherwise, return DISK_THRESHOLD.
+ *   
+ */
+static int
+parse_diskthreshold (int argc, char **line_args, struct GpmSolarisConfPrivate *pc)
+{
+	int value;
+	char *phy_path = NULL;
+	int i;
+	
+	if (argc != 3) {
+		g_warning ("Invalid syntax for device-thresholds disk,"
+			"which expects 2 parameters!\n");
+		return UNKNOWN;
+	}	
+	
+	/* Only care harddisk type devices */
+	if (devpath (&phy_path, line_args[1]))
+		return -1;
+	for (i = 0; i < pc->disk_num; i++)
+		if (strcmp (pc->disk_list[i], phy_path) == 0)
+			break;
+	if (i == pc->disk_num)
+		return UNKNOWN;
+
+	/* Only keep the maxinum of threshold */
+	if (value = parse_threshold (line_args[2]))
+		return -1;
+	if (value > pc->disk_threshold) 
+		pc->disk_threshold = value;
+	
+	return DISK_THRESHOLD;
+}
+
+static int
+parse_autopm (int argc, char ** line_args, struct GpmSolarisConfPrivate *pc)
+{
+	if (argc != 2) {
+		g_warning ("Invalid syntax for autopm, which expects 1 parameters!\n");
+		return -1;
+	}
+	
+	if ((pc->autopm_default && (strcmp("default", line_args[1]) == 0)) 
+	      || (strcmp("enable", line_args[1]) == 0))
+	    pc->autopm_enabled = TRUE;
+	else 
+	    pc->autopm_enabled = FALSE;
+	
+	return AUTOPM;
+}
+
+/*
+ * Check for valid autoS3 behavior.
+ */
+static int
+parse_autoS3(int argc, char **line_args, struct GpmSolarisConfPrivate *pc)
+{
+	if (argc != 2) {
+		g_warning ("Invalid syntax for autoS3, which expected 1 parameters!\n");
+		return -1;
+	}
+
+	if ((pc->autoS3_default && (strcmp("default", line_args[1]) == 0)) 
+	      || (pc->autoS3_capable && (strcmp("enable", line_args[1]) == 0)))
+	    pc->autoS3_enabled = TRUE;
+	else 
+	    pc->autoS3_enabled = FALSE;
+	    
+	return AUTOS3;
+}
+
+static int
+parse_comment(int argc, char **line_args)
+{
+	return COMMENT;
+}
+
+static int
+get_hm(char *src, unsigned int *hour, unsigned int *min)
+{
+	if (sscanf(src, "%u:%u", hour, min) != 2) {
+		g_printf ("bad time format: %s\n", src);
+		return (-1);
+	}
+	return (0);
+}
+
+/*
+ * Convert autoshutdown idle and start/finish times;
+ * check and record autoshutdown behavior.
+ */
+static int
+parse_autosd(int argc, char **line_args, struct GpmSolarisConfPrivate *pc)
+{
+	char *sp, **bp;
+	char *blist[] = {
+		"autowakeup", "default", "noshutdown",
+		"shutdown", "unconfigured", NULL
+	};
+	char *behavior = NULL;
+
+	if (argc != 5) {
+		g_warning ("Invalid syntax for autoshudown, which expects 4 parameters!\n");
+		return (-1);
+	}
+
+	pc->as_idle = strtol (line_args[1], &sp, 0) * 60;
+	if (get_hm (line_args[2], &pc->as_sh, &pc->as_sm) ||
+	    get_hm (line_args[3], &pc->as_fh, &pc->as_fm))
+		return (-1);
+	g_printf ("idle %d, start %d:%02d, finish %d:%02d\n",
+	    pc->as_idle, pc->as_sh, pc->as_sm,
+	    pc->as_fh, pc->as_fm);
+
+	for (behavior = line_args[4], bp = blist; *bp; bp++) {
+		if (strcmp(behavior, *bp) == 0)
+			break;
+	}
+	if (*bp == NULL) {
+		g_warning ("%s: \"%s\"\n", "unrecognized autoshutdown behavior", behavior);
+		return (-1);
+	}
+	
+	if ((pc->asd_default && (strcmp("default", line_args[4]) == 0)) 
+	    || (pc->asd_capable 
+	    	    && ((strcmp("shutdown", line_args[4]) == 0) 
+	    	       || (strcmp("autowakeup", line_args[4]) == 0)))) 
+		pc->asd_enabled = TRUE;
+	else 
+		pc->asd_enabled = FALSE;
+	
+	if(pc->wakeup_capable && (strcmp("autowakeup", line_args[4]) == 0))
+		pc->wakeup_enabled = TRUE;
+	else
+		pc->wakeup_enabled = FALSE;
+		
+	return (0);
+}
+
+        
+static int
+get_command_number (const char *cmd)
+{
+	if (strcmp (cmd, "#") == 0) {
+		return COMMENT;
+	} else if (strcmp (cmd, "autopm") == 0) {
+		return AUTOPM;	
+	} else if (strcmp (cmd, "system-threshold") == 0) {
+		return SYSTEM_THRESHOLD;
+	} else if (strcmp (cmd, "device-thresholds") == 0) {
+		return DEVICE_THRESHOLDS;
+	} else if (strcmp (cmd, "autoS3") == 0) {
+		return AUTOS3;
+	} else if (strcmp (cmd, "statefile") == 0) {
+		return STATEFILE;
+	} else if (strcmp (cmd, "autoshutdown") == 0) {
+		return AUTOSHUTDOWN;
+	} else {
+		return UNKNOWN;
+	}
+}
+
+
+/*
+ * Find the end of a [possibly continued] conf line
+ * and record the real/lf-delimited line count at *lcnt.
+ */
+static char *
+find_line_end (char *line, int *lcnt)
+{
+	char *next, *lf;
+
+	*lcnt = 0;
+	next = line;
+	while (lf = strchr (next, '\n')) {
+		(*lcnt)++;
+		if (lf == line || (*(lf - 1) != '\\') || *(lf + 1) == '\0')
+			break;
+		next = lf + 1;
+	}
+	return (lf);
+}
+
+/*
+ * Alloc space and read a config file; caller needs to free the space.
+ */
+static char *
+get_conf_data (const char *name)
+{
+	struct stat stbuf;
+	ssize_t nread;
+	size_t size;
+	char *buf;
+	int fd;
+
+	if ((fd = open(name, O_RDONLY)) == -1)
+		g_warning ("cannot open %s\n", name);
+	else if (fstat (fd, &stbuf) == -1)
+		g_warning ("cannot stat %s\n", name);
+	size = (size_t)stbuf.st_size;
+	if ((buf = malloc (size + 1)) == NULL)
+		g_warning ("cannot allocate %u for \"%s\"\n", size + 1, name);
+	nread = read(fd, buf, size);
+	(void) close(fd);
+	if (nread != (ssize_t)size)
+		g_warning ("read error, expect %u, got %d, file \"%s\"\n",
+		    size, nread, name);
+	*(buf + size) = '\0';
+	return (buf);
+}
+
+
+/*
+ * Convert blank-delimited words into an arg vector and return
+ * the arg count; character strings get null-terminated in place.
+ */
+static int
+build_args (const char *cline, int llen, char **argv)
+{
+	char *arg, *cp, *line = NULL;
+	int cnt = 0;
+
+	if (!cline)
+		return -1;
+	line = g_strdup (cline);
+
+	/*
+	 * Search logic: look for "\\\n" as a continuation marker,
+	 * treat any other "\\*" as ordinary arg data, scan until a
+	 * white-space delimiter is found, and if the arg has length,
+	 * null-terminate and save arg to line_args.  The scan includes
+	 * tail so the last arg is found without any special-case code.
+	 */
+	for (arg = cp = line; cp <= line+llen; cp++) {
+		if (*cp == '\\') {
+			if (*(cp + 1) && *(cp + 1) != '\n') {
+				cp++;
+				continue;
+			}
+		} else if (strchr (" \t\n", *cp) == NULL)
+			continue;
+		if (cp - arg) {
+			*cp = '\0';
+			argv[cnt++] = arg;
+		}
+		arg = cp + 1;
+	}
+	argv[cnt] = NULL;
+	g_free (line);
+
+	return (cnt);
+}
+
+/*
+ * For blank and comment lines: possibly show a debug
+ * message and otherwise ignore them.  For other lines:
+ * parse into an arg vector and try to match the first
+ * arg with conftab keywords.  When a match is found,
+ * check for exact or minimum arg count, and call the
+ * action or handler routine; if handler does not return
+ * OKUP, set the referenced update value to NOUP so that
+ * later CPR or PM updates are skipped.
+ */
+static int
+identify_line (const char *cline, int llen, struct GpmSolarisConfPrivate *pc)
+{		
+	int cnt;
+	char *line_args[10] = {NULL};
+	
+	if (llen == 0) {
+		g_printf ("\nline, blank...\n");
+	} else if (*cline == '#') {
+		g_printf ("\nline ===comment===\n\t%s...\n", cline);
+		return COMMENT;
+	} else if (*cline == '/') {
+		g_printf ("\nline ===device name===\n\t%s...\n", cline);
+	} else if (cnt = build_args (cline, llen, line_args)) {
+		switch (get_command_number (line_args[0])) {
+			case AUTOPM:
+				return parse_autopm (cnt, line_args, pc); 
+			case SYSTEM_THRESHOLD:
+				return parse_systhreshold (cnt, line_args, pc);
+			case DEVICE_THRESHOLDS:
+				return parse_diskthreshold (cnt, line_args, pc); 
+			case AUTOS3:
+				return parse_autoS3 (cnt, line_args, pc);
+			case AUTOSHUTDOWN:
+				return parse_autosd (cnt, line_args, pc);
+  		}
+  	}
+	return UNKNOWN;
+}
+
+/*
+ * Parse the named conf file and for each conf line
+ * call the action routine or conftab handler routine.
+ */
+static void
+parse_conf_file(char *name, struct GpmSolarisConfPrivate * pc)
+{
+	char *file_buf, *cmd, *line, *cline, *lend;
+	char **line_args;
+	int lineno = 0;
+	int linc;
+	size_t llen;
+	
+
+	file_buf = get_conf_data(name);
+	memset (pc, sizeof(struct GpmSolarisConfPrivate), 0);
+	g_printf ("\nnow parsing \"%s\"...\n", name);
+
+	lineno = 1;
+	line = file_buf;
+	while (lend = find_line_end (line, &linc)) {
+		/*
+		 * Each line should start with valid data
+		 * but leading white-space can be ignored
+		 */
+		while (line < lend) {
+			if (*line != ' ' && *line != '\t')
+				break;
+			line++;
+		}
+	
+		/*
+		 * Copy line into allocated space and null-terminate
+		 * without the trailing line-feed.
+		 */
+		if ((llen = (lend - line)) != 0) {
+			if ((cline = malloc (llen + 1)) == NULL)
+				g_warning ("cannot alloc %u bytes for line copy\n", llen);
+			(void) memcpy (cline, line, llen);
+			*(cline + llen) = '\0';
+		} else {
+			cline = NULL;
+		}
+
+		if (cline && identify_line (cline, llen, pc) == UNKNOWN) {
+			if (!pc->unidentified) {
+				pc->unidentified = g_strdup_printf ("%s\n", cline);
+			} else {
+				gchar *tmp = pc->unidentified;
+				pc->unidentified = g_strdup_printf ("%s%s\n", tmp, cline);
+				g_free (tmp);
+			}
+		}
+		free (cline);
+		
+		line = lend + 1;
+		lineno += linc;
+	}
+	
+	free (file_buf);
+}
+
+
+
+
+/**
+ * Construct and write text commands appropriate for a power managment
+ * system config file (/etc/power.conf).
+ */ 
+static char *
+build_autopm (gboolean enable)
+{
+	return g_strdup_printf ("autopm\t\t%s\n", 
+				(enable ? "enable" : "disable"));
+}
+
+static char *
+build_autoS3 (gboolean enable)
+{
+	return g_strdup_printf ("autoS3\t\t%s\n", 
+				(enable ? "enable" : "disable"));
+}
+
+static gchar *
+build_threshold (int seconds)
+{
+	gchar *time = NULL;
+		
+	if (seconds == INT_MAX) {
+		time = g_strdup ("always-on");
+	} else {
+		time = g_strdup_printf ("%ds", seconds);
+	}
+		
+	return time;
+}
+
+static char *
+build_systhreshold (int seconds)
+{
+	gchar *cmd = NULL;
+	gchar *tmp;
+
+	if (seconds > 0 && (tmp = build_threshold (seconds))) {
+		cmd = g_strdup_printf ("system-threshold\t\t%s\n", tmp);
+		g_free (tmp);
+	}
+	return cmd;
+}
+
+static char *
+build_diskthreshold (struct GpmSolarisConfPrivate *pc)
+{
+	gchar *cmd = NULL;
+	gchar *tmp;
+	int i;
+
+	if (pc->disk_threshold <= 0 || pc->disk_num == 0)
+		return NULL;
+
+	for (i = 0; i < pc->disk_num; i++) {
+		if (tmp = build_threshold (pc->disk_threshold)) 
+			cmd = g_strdup_printf ("device-thresholds\t\t%s\t%s\n", 
+				pc->disk_list[i], tmp);
+		g_free (tmp);
+	}
+	return cmd;
+}
+
+static char *
+build_autosd (struct GpmSolarisConfPrivate *pc)
+{
+	gchar *behavior = NULL;
+	gchar *cmd = NULL;
+	char comment[] =
+		"# Auto-Shutdown\tIdle(min)\tStart/Finish(hh:mm)\tBehavior\n";
+	
+	/* Do nothing when system doesn't support autoshudown */	
+	if (pc->asd_capable == FALSE)
+		return NULL;
+
+	/* Interept 0 as noshutdown */
+	if (pc->as_idle == 0)
+		pc->asd_enabled = FALSE;
+
+	if (pc->wakeup_enabled)
+		behavior = g_strdup ("autowakeup");
+	else if (pc->asd_enabled)
+		behavior = g_strdup ("shutdown");
+	else 
+		behavior = g_strdup ("noshutdown");
+		
+	cmd = g_strdup_printf ("%s"
+				"autoshutdown\t"
+				"%d\t\t"
+				"%d:%02d "
+				"%d:%02d\t\t\t"
+				"%s\n",
+				comment,pc->as_idle/60,
+				pc->as_sh, pc->as_sm, 
+				pc->as_fh, pc->as_fm, 
+				behavior);
+	g_free (behavior);
+	return cmd;
+}
+
+static gboolean
+exec_pmconfig (const char *tmp_config_file)
+{
+	int status = 0;
+	pid_t pid, wp;
+	char *program = "/usr/sbin/pmconfig";
+	
+	if ((pid = fork()) == NOPID)
+		wp = -1;
+	else if (pid == P_MYPID) {
+		(void) execle (program, program, "-f", tmp_config_file, NULL, NULL);
+		exit(1);
+	} else {
+		do {
+			wp = waitpid (pid, &status, 0);
+		} while (wp == -1 && errno == EINTR);
+	}
+
+	if (wp == -1)
+		g_warning ("Fail to run %s\n", program);
+	return (wp == -1 || status != 0);
+}
+
+/**
+ * Change the machine's power state by generating a command file used
+ * by a helper program (pmconfig).  The file consists of valid power.conf
+ * commands.  Invoke the helper program to make the change.
+ */
+static gboolean
+change_power_state(struct GpmSolarisConfPrivate *pc)
+{
+	int fd;
+	char *line = NULL;
+	char *tmp_config_file = "/tmp/power.confXXXX";
+
+	fd = open (tmp_config_file, O_RDWR | O_TRUNC | O_CREAT, 0644);
+	if (!fd) {
+		g_warning ("Failed to open %s\n", tmp_config_file);
+		return FALSE;
+	}
+
+	if (pc->unidentified && write (fd, pc->unidentified, strlen (pc->unidentified)) == -1) {
+  		g_warning ("Failed to write unidentified line\n");
+		goto out;
+	}
+
+	line = build_autopm (pc->autopm_enabled);
+	if (line && write (fd, line, strlen (line)) == -1) {
+		g_warning ("Failed to write autopm line to config file\n");
+		goto out;
+	}
+	g_free (line);
+
+	line = build_systhreshold (pc->sys_threshold);
+	if (line && write (fd, line, strlen (line)) == -1) {
+		g_warning ("Failed to write systhreshold line to config file\n");
+		goto out;
+	}
+	g_free (line);
+	
+	line = build_diskthreshold (pc);	
+	if (line && write (fd, line, strlen (line)) == -1) {
+		g_warning ("Failed to write device-thresholds [disk] line to config file\n");
+		goto out;
+	}
+	g_free (line);
+
+	line = build_autoS3 (pc->autoS3_enabled);
+	if (line && write (fd, line, strlen (line)) == -1) {
+		g_warning ("Failed to write autoS3 line to config file\n");
+		goto out;
+	}
+	g_free (line);
+	
+	line = build_autosd (pc);
+	if (line && write (fd, line, strlen (line)) == -1) {
+		g_warning ("Failed to write autoshutdown line to config file\n");
+		goto out;;
+	}
+	g_free (line);
+
+	close(fd);
+	if (pc->asd_change_perm || pc->pm_change_perm) {
+		return exec_pmconfig (tmp_config_file);	
+	} else {
+		g_warning ("You have no enough permission to change PM or CPR "
+			"configuration.!!!!\nPlease check /etc/default/power.\n");
+		return FALSE;
+	}
+
+out:
+	g_free (line);
+	close (fd);
+	return FALSE;
+}
+
+
+gboolean
+gpm_solaris_conf_sync_policy (GpmSolarisConf *sc)
+{
+	g_return_val_if_fail (sc != NULL, FALSE);
+	g_return_val_if_fail (GPM_IS_SOLARIS_CONF (sc), FALSE);
+
+	return change_power_state (sc->priv);
+}
+
+gboolean
+gpm_solaris_conf_get_autoS3_capable (GpmSolarisConf *sc)
+{
+	g_return_val_if_fail (sc != NULL, FALSE);
+	g_return_val_if_fail (GPM_IS_SOLARIS_CONF (sc), FALSE);
+
+	return sc->priv->autoS3_capable;
+}
+
+gboolean
+gpm_solaris_conf_get_autoshutdown_capable (GpmSolarisConf *sc)
+{
+	g_return_val_if_fail (sc != NULL, FALSE);
+	g_return_val_if_fail (GPM_IS_SOLARIS_CONF (sc), FALSE);
+
+	return sc->priv->asd_capable;
+}
+
+gboolean
+gpm_solaris_conf_get_autoshutdown_perm (GpmSolarisConf *sc)
+{
+	g_return_val_if_fail (sc != NULL, FALSE);
+	g_return_val_if_fail (GPM_IS_SOLARIS_CONF (sc), FALSE);
+
+	return sc->priv->asd_change_perm;
+}
+
+gboolean
+gpm_solaris_conf_get_pm_perm (GpmSolarisConf *sc)
+{
+	g_return_val_if_fail (sc != NULL, FALSE);
+	g_return_val_if_fail (GPM_IS_SOLARIS_CONF (sc), FALSE);
+
+	return sc->priv->pm_change_perm;
+}
+
+static void
+sync_from_gconf_to_solaris_conf (GpmSolarisConf *sc)
+{
+	guint sys_thresh, disk, as_idle;
+	gboolean autoS3_enabled;	
+	gboolean on_ac;
+
+	on_ac = gpm_ac_adapter_is_present (sc->priv->ac_adapter);
+	if (on_ac == TRUE) {
+		gpm_conf_get_uint (sc->priv->conf, GPM_CONF_SOLARIS_TIMEOUT_SLEEP_COMPUTER_AC, &sys_thresh);
+		gpm_conf_get_bool (sc->priv->conf, GPM_CONF_SOLARIS_SUSPEND_AC, &autoS3_enabled);
+		gpm_conf_get_uint (sc->priv->conf, GPM_CONF_SOLARIS_TIMEOUT_SLEEP_DISK_AC, &disk);
+		gpm_conf_get_uint (sc->priv->conf, GPM_CONF_SOLARIS_TIMEOUT_HIBERNATE_AC, &as_idle);
+	} else {
+		gpm_conf_get_uint (sc->priv->conf, GPM_CONF_SOLARIS_TIMEOUT_SLEEP_COMPUTER_BATT, &sys_thresh);
+		gpm_conf_get_bool (sc->priv->conf, GPM_CONF_SOLARIS_SUSPEND_BATT, &autoS3_enabled);
+		gpm_conf_get_uint (sc->priv->conf, GPM_CONF_SOLARIS_TIMEOUT_SLEEP_DISK_BATT, &disk);
+		gpm_conf_get_uint (sc->priv->conf, GPM_CONF_SOLARIS_TIMEOUT_HIBERNATE_BATT, &as_idle);
+	} 
+
+	sc->priv->autopm_enabled = (sys_thresh != 0)? TRUE : FALSE;
+	sc->priv->sys_threshold = sys_thresh;
+	sc->priv->autoS3_enabled = autoS3_enabled;	
+	sc->priv->disk_threshold = disk;
+	sc->priv->asd_enabled = (as_idle != 0)? TRUE : FALSE;
+	sc->priv->as_idle = as_idle;
+	sc->priv->as_sh = 9;
+	sc->priv->as_sm = 0;
+	sc->priv->as_fh = 9;
+	sc->priv->as_fm = 0;
+
+	gpm_solaris_conf_sync_policy (sc);
+}
+
+/**
+ * conf_key_changed_cb:
+ * 
+ * We might have to do things when the gconf keys change; do them here.
+ * Solaris-specific timeout including autopm, disk-thresholds and
+ * autoshutdown, is wrote back to "power.conf" instead of gconf.
+ **/
+static void
+conf_key_changed_cb (GpmConf      *conf,
+		     const gchar  *key,
+		     GpmSolarisConf *sc)
+{	
+	if (strcmp (key, GPM_CONF_SOLARIS_TIMEOUT_SLEEP_COMPUTER_AC) == 0
+	  || strcmp (key, GPM_CONF_SOLARIS_SUSPEND_AC) == 0
+	  || strcmp (key, GPM_CONF_SOLARIS_TIMEOUT_SLEEP_DISK_AC) == 0
+	  || strcmp (key, GPM_CONF_SOLARIS_TIMEOUT_HIBERNATE_AC) == 0 			
+	  || strcmp (key, GPM_CONF_SOLARIS_TIMEOUT_SLEEP_COMPUTER_BATT) == 0
+	  || strcmp (key, GPM_CONF_SOLARIS_SUSPEND_BATT) == 0
+	  || strcmp (key, GPM_CONF_SOLARIS_TIMEOUT_SLEEP_DISK_BATT) == 0
+	  || strcmp (key, GPM_CONF_SOLARIS_TIMEOUT_HIBERNATE_BATT) == 0) {
+		sync_from_gconf_to_solaris_conf (sc);
+	}				
+}
+/**
+ * gpm_solaris_conf_finalize:
+ **/
+static void
+gpm_solaris_conf_finalize (GObject *object)
+{
+	GpmSolarisConf *sc;
+	int i;
+
+	g_return_if_fail (object != NULL);
+	g_return_if_fail (GPM_IS_SOLARIS_CONF (object));
+	sc = GPM_SOLARIS_CONF (object);
+
+	if (sc->priv->conf != NULL) {
+		g_object_unref (sc->priv->conf);
+	}
+
+	if (sc->priv->ac_adapter != NULL) {
+		g_object_unref (sc->priv->ac_adapter);
+	}
+
+	for (i = 0; i < sc->priv->disk_num; i++)
+		g_free (sc->priv->disk_list[i]);
+	g_free (sc->priv->unidentified);
+
+	G_OBJECT_CLASS (gpm_solaris_conf_parent_class)->finalize (object);
+}
+
+/**
+ * gpm_solaris_conf_class_init:
+ **/
+static void
+gpm_solaris_conf_class_init (GpmSolarisConfClass *klass)
+{
+	GObjectClass *object_class = G_OBJECT_CLASS (klass);
+	object_class->finalize	   = gpm_solaris_conf_finalize;
+
+	g_type_class_add_private (klass, sizeof (GpmSolarisConfPrivate));
+}
+
+/**
+ * ac_adapter_changed_cb:
+ * @ac_adapter: The ac_adapter class instance
+ * @on_ac: if we are on AC power
+ * @brightness: This class instance
+ *
+ * Does the actions when the ac power source is inserted/removed.
+ **/
+static void
+ac_adapter_changed_cb (GpmAcAdapter     *ac_adapter,
+		       gboolean		 on_ac,
+		       GpmSolarisConf   *solarisconf)
+{
+	sync_from_gconf_to_solaris_conf (solarisconf);
+}
+
+/**
+ * gpm_solaris_conf_init:
+ * @sc: This solaris conf class instance
+ *
+ * initialises the solaris conf class. 
+ **/
+static void
+gpm_solaris_conf_init (GpmSolarisConf *sc)
+{
+	cpr_info_t *ci;
+	perm_t *perm;
+
+	sc->priv = GPM_SOLARIS_CONF_GET_PRIVATE (sc);
+
+	/* watch for solaris-specific value changes */
+	sc->priv->conf = gpm_conf_new ();
+	g_signal_connect (sc->priv->conf, "value-changed",
+			  G_CALLBACK (conf_key_changed_cb), sc);
+
+	/* we use ac_adapter for the ac-adapter-changed signal */
+	sc->priv->ac_adapter = gpm_ac_adapter_new ();
+	g_signal_connect (sc->priv->ac_adapter, "ac-adapter-changed",
+			  G_CALLBACK (ac_adapter_changed_cb), sc);
+	
+	ci = gpm_system_interrogater_get_cpr_info ();
+	if (ci) {
+		sc->priv->asd_capable = ci->asd_capable;
+		sc->priv->asd_default = ci->asd_default;
+		sc->priv->wakeup_capable = ci->wakeup_capable;
+		sc->priv->autopm_default = ci->autopm_default;
+		sc->priv->autoS3_capable = ci->autoS3_capable;
+		sc->priv->autoS3_default = ci->autoS3_default;
+		g_free (ci);
+	}
+	
+	perm = gpm_system_interrogator_get_perm ();
+	if (perm) {
+		sc->priv->asd_change_perm = perm->asd_change_perm;
+		sc->priv->pm_change_perm = perm->pm_change_perm;
+		g_free (perm);
+	}	
+	
+	sc->priv->disk_num = gpm_system_interrogator_get_all_device_names (&sc->priv->disk_list);
+
+	parse_conf_file ("/etc/power.conf", sc->priv);
+}
+/**
+ * gpm_solaris_conf_new:
+ * Return value: A new solaris conf class instance.
+ **/
+GpmSolarisConf *
+gpm_solaris_conf_new (void)
+{
+	if (gpm_solaris_conf_object != NULL) {
+		g_object_ref (gpm_solaris_conf_object);
+	} else {
+		gpm_solaris_conf_object = g_object_new (GPM_TYPE_SOLARIS_CONF, NULL);
+		g_object_add_weak_pointer (gpm_solaris_conf_object, &gpm_solaris_conf_object);
+	}
+	return GPM_SOLARIS_CONF (gpm_solaris_conf_object);
+}
+
--- src/gpm-solaris-conf.h.org	1970-01-01 08:00:00.000000000 +0800
+++ src/gpm-solaris-conf.h	2007-12-05 16:23:44.637056000 +0800
@@ -0,0 +1,62 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2007 Richard Hughes <simon.zheng@sun.com>
+ *
+ * Licensed under the GNU General Public License Version 2
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef GPM_SOLARIS_CONF_H
+#define GPM_SOLARIS_CONF_H
+
+G_BEGIN_DECLS
+
+#define GPM_TYPE_SOLARIS_CONF		(gpm_solaris_conf_get_type ())
+#define GPM_SOLARIS_CONF(o)		(G_TYPE_CHECK_INSTANCE_CAST ((o), GPM_TYPE_SOLARIS_CONF, GpmSolarisConf))
+#define GPM_SOLARIS_CONF_CLASS(k)	(G_TYPE_CHECK_CLASS_CAST((k), GPM_TYPE_SOLARIS_CONF, GpmSolarisConfClass))
+#define GPM_IS_SOLARIS_CONF(o)		(G_TYPE_CHECK_INSTANCE_TYPE ((o), GPM_TYPE_SOLARIS_CONF))
+#define GPM_IS_SOLARIS_CONF_CLASS(k)	(G_TYPE_CHECK_CLASS_TYPE ((k), GPM_TYPE_SOLARIS_CONF))
+#define GPM_SOLARIS_CONF_GET_CLASS(o)	(G_TYPE_INSTANCE_GET_CLASS ((o), GPM_TYPE_SOLARIS_CONF, GpmSolarisConfClass))
+
+typedef struct GpmSolarisConfPrivate GpmSolarisConfPrivate;
+
+typedef struct
+{
+	GObject	 	parent;
+	GpmSolarisConfPrivate *priv;
+} GpmSolarisConf;
+
+typedef struct
+{
+	GObjectClass	parent_class;
+} GpmSolarisConfClass;
+
+
+GType		 gpm_solaris_conf_get_type	(void);
+GpmSolarisConf  *gpm_solaris_conf_new	(void);
+gboolean	 gpm_solaris_conf_sync (GpmSolarisConf *pc);
+gboolean	 gpm_solaris_conf_sync_policy (GpmSolarisConf *sc);
+gboolean	 gpm_solaris_conf_get_autoS3_capable (GpmSolarisConf *sc);
+gboolean	 gpm_solaris_conf_get_autoshutdown_capable (GpmSolarisConf *sc);
+gboolean	 gpm_solaris_conf_get_pm_perm (GpmSolarisConf *sc);
+gboolean	 gpm_solaris_conf_get_autoshutdown_perm (GpmSolarisConf *sc);
+
+G_END_DECLS
+
+#endif   /*GPM_SOLARIS_CONF_H*/
+
+
+
